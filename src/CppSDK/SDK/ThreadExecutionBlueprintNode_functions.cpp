#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ThreadExecutionBlueprintNode

#include "Basic.hpp"

#include "ThreadExecutionBlueprintNode_classes.hpp"
#include "ThreadExecutionBlueprintNode_parameters.hpp"


namespace SDK
{

// Function ThreadExecutionBlueprintNode.AsyncExecutionBlueprintTypes.Conv_ThreadTickTimingToTickingGroup
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const EThreadTickTiming&                ThreadTickTiming                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETickingGroup                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETickingGroup UAsyncExecutionBlueprintTypes::Conv_ThreadTickTimingToTickingGroup(const EThreadTickTiming& ThreadTickTiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncExecutionBlueprintTypes", "Conv_ThreadTickTimingToTickingGroup");

	Params::AsyncExecutionBlueprintTypes_Conv_ThreadTickTimingToTickingGroup Parms{};

	Parms.ThreadTickTiming = ThreadTickTiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.AsyncExecutionBlueprintTypes.Conv_TickingGroupToThreadTickTiming
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const ETickingGroup&                    TickGroup                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EThreadTickTiming                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EThreadTickTiming UAsyncExecutionBlueprintTypes::Conv_TickingGroupToThreadTickTiming(const ETickingGroup& TickGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncExecutionBlueprintTypes", "Conv_TickingGroupToThreadTickTiming");

	Params::AsyncExecutionBlueprintTypes_Conv_TickingGroupToThreadTickTiming Parms{};

	Parms.TickGroup = TickGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.Mutex.Lock
// (Final, Native, Public, BlueprintCallable)

void UMutex::Lock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mutex", "Lock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.Mutex.TryLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMutex::TryLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mutex", "TryLock");

	Params::Mutex_TryLock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.Mutex.UnLock
// (Final, Native, Public, BlueprintCallable)

void UMutex::UnLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mutex", "UnLock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.SyncExecOnce.CreateSyncExecOnce
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USyncExecOnce*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USyncExecOnce* USyncExecOnce::CreateSyncExecOnce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SyncExecOnce", "CreateSyncExecOnce");

	Params::SyncExecOnce_CreateSyncExecOnce Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLibrary.ExecIsGameThread
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   bIsInGameThread                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreadAsyncExecLibrary::ExecIsGameThread(bool* bIsInGameThread)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecLibrary", "ExecIsGameThread");

	Params::ThreadAsyncExecLibrary_ExecIsGameThread Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsInGameThread != nullptr)
		*bIsInGameThread = Parms.bIsInGameThread;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLibrary.GameThreadExecOnce
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TDelegate<void()>&                GameThreadExec                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreadAsyncExecLibrary::GameThreadExecOnce(const TDelegate<void()>& GameThreadExec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecLibrary", "GameThreadExecOnce");

	Params::ThreadAsyncExecLibrary_GameThreadExecOnce Parms{};

	Parms.GameThreadExec = GameThreadExec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLibrary.GetCurrentThreadID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UThreadAsyncExecLibrary::GetCurrentThreadID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecLibrary", "GetCurrentThreadID");

	Params::ThreadAsyncExecLibrary_GetCurrentThreadID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLibrary.GetThreadName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UThreadAsyncExecLibrary::GetThreadName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecLibrary", "GetThreadName");

	Params::ThreadAsyncExecLibrary_GetThreadName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLibrary.IsGameThread
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThreadAsyncExecLibrary::IsGameThread()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecLibrary", "IsGameThread");

	Params::ThreadAsyncExecLibrary_IsGameThread Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLibrary.SetThreadName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ThreadName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThreadAsyncExecLibrary::SetThreadName(class FName ThreadName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecLibrary", "SetThreadName");

	Params::ThreadAsyncExecLibrary_SetThreadName Parms{};

	Parms.ThreadName = ThreadName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLibrary.ThreadWait
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreadAsyncExecLibrary::ThreadWait(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecLibrary", "ThreadWait");

	Params::ThreadAsyncExecLibrary_ThreadWait Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLoopUnsafely.CreateThreadExecLoopUnsafely
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLongTask                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThreadName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockGC                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UThreadAsyncExecLoopUnsafely*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UThreadAsyncExecLoopUnsafely* UThreadAsyncExecLoopUnsafely::CreateThreadExecLoopUnsafely(float Interval, bool bLongTask, class FName ThreadName, bool bBlockGC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecLoopUnsafely", "CreateThreadExecLoopUnsafely");

	Params::ThreadAsyncExecLoopUnsafely_CreateThreadExecLoopUnsafely Parms{};

	Parms.Interval = Interval;
	Parms.bLongTask = bLongTask;
	Parms.ThreadName = ThreadName;
	Parms.bBlockGC = bBlockGC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecLoopUnsafely.BreakNextLoop
// (Final, Native, Public, BlueprintCallable)

void UThreadAsyncExecLoopUnsafely::BreakNextLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecLoopUnsafely", "BreakNextLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecOnce.CreateThreadExecOnce
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bExecuteWhenPaused                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLongTask                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThreadName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FThreadExecTimingPair&     TimingPair                                             (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// class UThreadAsyncExecOnce*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UThreadAsyncExecOnce* UThreadAsyncExecOnce::CreateThreadExecOnce(bool bExecuteWhenPaused, bool bLongTask, class FName ThreadName, const struct FThreadExecTimingPair& TimingPair)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecOnce", "CreateThreadExecOnce");

	Params::ThreadAsyncExecOnce_CreateThreadExecOnce Parms{};

	Parms.bExecuteWhenPaused = bExecuteWhenPaused;
	Parms.bLongTask = bLongTask;
	Parms.ThreadName = ThreadName;
	Parms.TimingPair = std::move(TimingPair);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecOnce.IsExecuteWhenPaused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThreadAsyncExecOnce::IsExecuteWhenPaused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecOnce", "IsExecuteWhenPaused");

	Params::ThreadAsyncExecOnce_IsExecuteWhenPaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecOnceUnsafely.CreateThreadExecOnceUnsafely
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bLongTask                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThreadName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockGC                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UThreadAsyncExecOnceUnsafely*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UThreadAsyncExecOnceUnsafely* UThreadAsyncExecOnceUnsafely::CreateThreadExecOnceUnsafely(bool bLongTask, class FName ThreadName, bool bBlockGC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecOnceUnsafely", "CreateThreadExecOnceUnsafely");

	Params::ThreadAsyncExecOnceUnsafely_CreateThreadExecOnceUnsafely Parms{};

	Parms.bLongTask = bLongTask;
	Parms.ThreadName = ThreadName;
	Parms.bBlockGC = bBlockGC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase.BreakNextTick
// (Final, Native, Public, BlueprintCallable)

void UThreadAsyncExecTickBase::BreakNextTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickBase", "BreakNextTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase.SetTickableWhenPaused
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreadAsyncExecTickBase::SetTickableWhenPaused(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickBase", "SetTickableWhenPaused");

	Params::ThreadAsyncExecTickBase_SetTickableWhenPaused Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase.SetTickEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreadAsyncExecTickBase::SetTickEnabled(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickBase", "SetTickEnabled");

	Params::ThreadAsyncExecTickBase_SetTickEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase.GetBehavior
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FThreadTickExecBehavior          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FThreadTickExecBehavior UThreadAsyncExecTickBase::GetBehavior() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickBase", "GetBehavior");

	Params::ThreadAsyncExecTickBase_GetBehavior Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase.GetTimingPair
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FThreadExecTimingPair            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FThreadExecTimingPair UThreadAsyncExecTickBase::GetTimingPair() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickBase", "GetTimingPair");

	Params::ThreadAsyncExecTickBase_GetTimingPair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase.IsTickableWhenPaused
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThreadAsyncExecTickBase::IsTickableWhenPaused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickBase", "IsTickableWhenPaused");

	Params::ThreadAsyncExecTickBase_IsTickableWhenPaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase.IsTickEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThreadAsyncExecTickBase::IsTickEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickBase", "IsTickEnabled");

	Params::ThreadAsyncExecTickBase_IsTickEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase.IsTicking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThreadAsyncExecTickBase::IsTicking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickBase", "IsTicking");

	Params::ThreadAsyncExecTickBase_IsTicking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTick.CreateThreadExecTick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bTickEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTickWhenPaused                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLongTask                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThreadName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FThreadExecTimingPair&     TimingPair                                             (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const struct FThreadTickExecBehavior&   Behavior                                               (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// class UThreadAsyncExecTick*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UThreadAsyncExecTick* UThreadAsyncExecTick::CreateThreadExecTick(bool bTickEnabled, bool bTickWhenPaused, bool bLongTask, class FName ThreadName, const struct FThreadExecTimingPair& TimingPair, const struct FThreadTickExecBehavior& Behavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecTick", "CreateThreadExecTick");

	Params::ThreadAsyncExecTick_CreateThreadExecTick Parms{};

	Parms.bTickEnabled = bTickEnabled;
	Parms.bTickWhenPaused = bTickWhenPaused;
	Parms.bLongTask = bLongTask;
	Parms.ThreadName = ThreadName;
	Parms.TimingPair = std::move(TimingPair);
	Parms.Behavior = std::move(Behavior);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickForLoop.CreateThreadExecTickForLoop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   FirstIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LastIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTickEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTickWhenPaused                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLongTask                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThreadName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FThreadExecTimingPair&     TimingPair                                             (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const struct FThreadTickExecBehavior&   Behavior                                               (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// class UThreadAsyncExecTickForLoop*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UThreadAsyncExecTickForLoop* UThreadAsyncExecTickForLoop::CreateThreadExecTickForLoop(int32 FirstIndex, int32 LastIndex, bool bTickEnabled, bool bTickWhenPaused, bool bLongTask, class FName ThreadName, const struct FThreadExecTimingPair& TimingPair, const struct FThreadTickExecBehavior& Behavior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecTickForLoop", "CreateThreadExecTickForLoop");

	Params::ThreadAsyncExecTickForLoop_CreateThreadExecTickForLoop Parms{};

	Parms.FirstIndex = FirstIndex;
	Parms.LastIndex = LastIndex;
	Parms.bTickEnabled = bTickEnabled;
	Parms.bTickWhenPaused = bTickWhenPaused;
	Parms.bLongTask = bLongTask;
	Parms.ThreadName = ThreadName;
	Parms.TimingPair = std::move(TimingPair);
	Parms.Behavior = std::move(Behavior);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickForLoop.GetCurrentIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UThreadAsyncExecTickForLoop::GetCurrentIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickForLoop", "GetCurrentIndex");

	Params::ThreadAsyncExecTickForLoop_GetCurrentIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickForLoop.GetFirstIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UThreadAsyncExecTickForLoop::GetFirstIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickForLoop", "GetFirstIndex");

	Params::ThreadAsyncExecTickForLoop_GetFirstIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickForLoop.GetLastIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UThreadAsyncExecTickForLoop::GetLastIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickForLoop", "GetLastIndex");

	Params::ThreadAsyncExecTickForLoop_GetLastIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickUnsafely.CreateThreadExecTickUnsafely
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    TickEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TickWhenPaused                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLongTask                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThreadName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBlockGC                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UThreadAsyncExecTickUnsafely*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UThreadAsyncExecTickUnsafely* UThreadAsyncExecTickUnsafely::CreateThreadExecTickUnsafely(bool TickEnabled, bool TickWhenPaused, bool bLongTask, class FName ThreadName, bool bBlockGC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadAsyncExecTickUnsafely", "CreateThreadExecTickUnsafely");

	Params::ThreadAsyncExecTickUnsafely_CreateThreadExecTickUnsafely Parms{};

	Parms.TickEnabled = TickEnabled;
	Parms.TickWhenPaused = TickWhenPaused;
	Parms.bLongTask = bLongTask;
	Parms.ThreadName = ThreadName;
	Parms.bBlockGC = bBlockGC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickUnsafely.BreakNextTick
// (Final, Native, Public, BlueprintCallable)

void UThreadAsyncExecTickUnsafely::BreakNextTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickUnsafely", "BreakNextTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickUnsafely.SetTickable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreadAsyncExecTickUnsafely::SetTickable(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickUnsafely", "SetTickable");

	Params::ThreadAsyncExecTickUnsafely_SetTickable Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickUnsafely.SetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreadAsyncExecTickUnsafely::SetTickableWhenPaused(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickUnsafely", "SetTickableWhenPaused");

	Params::ThreadAsyncExecTickUnsafely_SetTickableWhenPaused Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickUnsafely.IsTickable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThreadAsyncExecTickUnsafely::IsTickable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickUnsafely", "IsTickable");

	Params::ThreadAsyncExecTickUnsafely_IsTickable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadAsyncExecTickUnsafely.IsTickableWhenPaused
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThreadAsyncExecTickUnsafely::IsTickableWhenPaused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadAsyncExecTickUnsafely", "IsTickableWhenPaused");

	Params::ThreadAsyncExecTickUnsafely_IsTickableWhenPaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadExecDeveloperSettings.Get
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UThreadExecDeveloperSettings*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UThreadExecDeveloperSettings* UThreadExecDeveloperSettings::Get()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThreadExecDeveloperSettings", "Get");

	Params::ThreadExecDeveloperSettings_Get Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadNodeSubsystem.CreateNewMutex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMutex*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMutex* UThreadNodeSubsystem::CreateNewMutex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadNodeSubsystem", "CreateNewMutex");

	Params::ThreadNodeSubsystem_CreateNewMutex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadNodeSubsystem.DestoryMutex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMutex*                           Mutex                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreadNodeSubsystem::DestoryMutex(class UMutex* Mutex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadNodeSubsystem", "DestoryMutex");

	Params::ThreadNodeSubsystem_DestoryMutex Parms{};

	Parms.Mutex = Mutex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThreadExecutionBlueprintNode.ThreadNodeSubsystem.GetAllMutexes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSet<class UMutex*>                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class UMutex*> UThreadNodeSubsystem::GetAllMutexes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadNodeSubsystem", "GetAllMutexes");

	Params::ThreadNodeSubsystem_GetAllMutexes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadNodeSubsystem.GetAllThreadExecLoops
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSet<class UThreadAsyncExecLoopUnsafely*>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class UThreadAsyncExecLoopUnsafely*> UThreadNodeSubsystem::GetAllThreadExecLoops()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadNodeSubsystem", "GetAllThreadExecLoops");

	Params::ThreadNodeSubsystem_GetAllThreadExecLoops Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadNodeSubsystem.GetAllThreadExecNodes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSet<class UThreadAsyncExecBase*>       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class UThreadAsyncExecBase*> UThreadNodeSubsystem::GetAllThreadExecNodes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadNodeSubsystem", "GetAllThreadExecNodes");

	Params::ThreadNodeSubsystem_GetAllThreadExecNodes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadNodeSubsystem.GetAllThreadExecOnces
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSet<class UThreadAsyncExecOnce*>       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class UThreadAsyncExecOnce*> UThreadNodeSubsystem::GetAllThreadExecOnces()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadNodeSubsystem", "GetAllThreadExecOnces");

	Params::ThreadNodeSubsystem_GetAllThreadExecOnces Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThreadExecutionBlueprintNode.ThreadNodeSubsystem.GetAllThreadExecTicks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSet<class UThreadAsyncExecTickBase*>   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class UThreadAsyncExecTickBase*> UThreadNodeSubsystem::GetAllThreadExecTicks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreadNodeSubsystem", "GetAllThreadExecTicks");

	Params::ThreadNodeSubsystem_GetAllThreadExecTicks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

