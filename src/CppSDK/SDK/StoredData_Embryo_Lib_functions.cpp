#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StoredData_Embryo_Lib

#include "Basic.hpp"

#include "StoredData_Embryo_Lib_classes.hpp"
#include "StoredData_Embryo_Lib_parameters.hpp"


namespace SDK
{

// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.AddStoredDataEntry_ViaCopying
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   StoredDataIndex                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Sender_To_Copy_From                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Reciever                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    SkipRoomCheck                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::AddStoredDataEntry_ViaCopying(struct FFunctionParams_NoArrays& Function_Params, int32 StoredDataIndex, class AActor* Sender_To_Copy_From, class FName& Function_Tag, class AActor* Reciever, bool SkipRoomCheck, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "AddStoredDataEntry_ViaCopying");

	Params::StoredData_Embryo_Lib_C_AddStoredDataEntry_ViaCopying Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.StoredDataIndex = StoredDataIndex;
	Parms.Sender_To_Copy_From = Sender_To_Copy_From;
	Parms.Function_Tag = Function_Tag;
	Parms.Reciever = Reciever;
	Parms.SkipRoomCheck = SkipRoomCheck;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.Can Target Add PARTICULAR Stored Data Entry Via Copying
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           SenderTransferringFrom                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           RecieverToTransferDataTo                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SkipRoomCheck                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   can_add                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::Can_Target_Add_PARTICULAR_Stored_Data_Entry_Via_Copying(struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class AActor* SenderTransferringFrom, class AActor* RecieverToTransferDataTo, int32 Entry_Index, bool SkipRoomCheck, bool* can_add, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "Can Target Add PARTICULAR Stored Data Entry Via Copying");

	Params::StoredData_Embryo_Lib_C_Can_Target_Add_PARTICULAR_Stored_Data_Entry_Via_Copying Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.SenderTransferringFrom = SenderTransferringFrom;
	Parms.RecieverToTransferDataTo = RecieverToTransferDataTo;
	Parms.Entry_Index = Entry_Index;
	Parms.SkipRoomCheck = SkipRoomCheck;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (can_add != nullptr)
		*can_add = Parms.can_add;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.Can Target Remove PARTICULAR Stored Data Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*&                          Entry_Owner                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// int32&                                  StoredDataIndexToTransfer                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           RequestedByActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::Can_Target_Remove_PARTICULAR_Stored_Data_Entry(struct FFunctionParams_NoArrays& Function_Params, class AActor*& Entry_Owner, int32& StoredDataIndexToTransfer, class FName& Function_Tag, class AActor* RequestedByActor, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "Can Target Remove PARTICULAR Stored Data Entry");

	Params::StoredData_Embryo_Lib_C_Can_Target_Remove_PARTICULAR_Stored_Data_Entry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Entry_Owner = Entry_Owner;
	Parms.StoredDataIndexToTransfer = StoredDataIndexToTransfer;
	Parms.Function_Tag = Function_Tag;
	Parms.RequestedByActor = RequestedByActor;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Entry_Owner = Parms.Entry_Owner;
	StoredDataIndexToTransfer = Parms.StoredDataIndexToTransfer;
	Function_Tag = Parms.Function_Tag;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.CanEditEmbryoDataAtEntry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// int32&                                  StoredDataIndexToTransfer                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::CanEditEmbryoDataAtEntry(struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class AActor*& Target, int32& StoredDataIndexToTransfer, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "CanEditEmbryoDataAtEntry");

	Params::StoredData_Embryo_Lib_C_CanEditEmbryoDataAtEntry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.Target = Target;
	Parms.StoredDataIndexToTransfer = StoredDataIndexToTransfer;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;
	Target = Parms.Target;
	StoredDataIndexToTransfer = Parms.StoredDataIndexToTransfer;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.ConvertEmbryoStructToCustomItemDatas
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FEmbryoData&               Embryo_Data                                            (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FCustomItemData*                 StoredEmbryoData1                                      (Parm, OutParm)
// struct FCustomItemData*                 StoredEmbryoData2                                      (Parm, OutParm)
// struct FCustomItemData*                 StoredEmbryoData3                                      (Parm, OutParm)
// struct FCustomItemData*                 StoredEmbryoData4                                      (Parm, OutParm)

void UStoredData_Embryo_Lib_C::ConvertEmbryoStructToCustomItemDatas(const struct FEmbryoData& Embryo_Data, struct FCustomItemData* StoredEmbryoData1, struct FCustomItemData* StoredEmbryoData2, struct FCustomItemData* StoredEmbryoData3, struct FCustomItemData* StoredEmbryoData4)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "ConvertEmbryoStructToCustomItemDatas");

	Params::StoredData_Embryo_Lib_C_ConvertEmbryoStructToCustomItemDatas Parms{};

	Parms.Embryo_Data = std::move(Embryo_Data);

	UObject::ProcessEvent(Func, &Parms);

	if (StoredEmbryoData1 != nullptr)
		*StoredEmbryoData1 = std::move(Parms.StoredEmbryoData1);

	if (StoredEmbryoData2 != nullptr)
		*StoredEmbryoData2 = std::move(Parms.StoredEmbryoData2);

	if (StoredEmbryoData3 != nullptr)
		*StoredEmbryoData3 = std::move(Parms.StoredEmbryoData3);

	if (StoredEmbryoData4 != nullptr)
		*StoredEmbryoData4 = std::move(Parms.StoredEmbryoData4);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.ConvertItemDatasIntoEmbryoStructs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCustomItemData&           StoredEmbryoData1                                      (BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FCustomItemData&           StoredEmbryoData2                                      (BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FCustomItemData&           StoredEmbryoData3                                      (BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FCustomItemData&           StoredEmbryoData4                                      (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FEmbryoData*                     EmbryoData                                             (Parm, OutParm, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::ConvertItemDatasIntoEmbryoStructs(const struct FCustomItemData& StoredEmbryoData1, const struct FCustomItemData& StoredEmbryoData2, const struct FCustomItemData& StoredEmbryoData3, const struct FCustomItemData& StoredEmbryoData4, struct FEmbryoData* EmbryoData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "ConvertItemDatasIntoEmbryoStructs");

	Params::StoredData_Embryo_Lib_C_ConvertItemDatasIntoEmbryoStructs Parms{};

	Parms.StoredEmbryoData1 = std::move(StoredEmbryoData1);
	Parms.StoredEmbryoData2 = std::move(StoredEmbryoData2);
	Parms.StoredEmbryoData3 = std::move(StoredEmbryoData3);
	Parms.StoredEmbryoData4 = std::move(StoredEmbryoData4);

	UObject::ProcessEvent(Func, &Parms);

	if (EmbryoData != nullptr)
		*EmbryoData = std::move(Parms.EmbryoData);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.EditStoredDataAtIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   StoredIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FEmbryoData&               EmbryoData                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::EditStoredDataAtIndex(int32 StoredIndex, const struct FEmbryoData& EmbryoData, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class AActor* Target, bool* success, class FString* Fail_Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "EditStoredDataAtIndex");

	Params::StoredData_Embryo_Lib_C_EditStoredDataAtIndex Parms{};

	Parms.StoredIndex = StoredIndex;
	Parms.EmbryoData = std::move(EmbryoData);
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason != nullptr)
		*Fail_Reason = std::move(Parms.Fail_Reason);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.Get Available Options for Interacting WIth An Entry_CommonActorLogic
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          StoredData_Entry_Owner                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Remote_Actor_To_Transfer_To                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32&                                  Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor_To_Call_Event_On                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>*                  Entry_Options                                          (Parm, OutParm)
// TArray<bool>*                           EntriesEnabled                                         (Parm, OutParm)
// class FString*                          Fail_Reason                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   Implemented                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::Get_Available_Options_for_Interacting_WIth_An_Entry_CommonActorLogic(class AActor*& StoredData_Entry_Owner, class AActor* Remote_Actor_To_Transfer_To, int32& Entry_Index, class AActor* Actor_To_Call_Event_On, TArray<class FString>* Entry_Options, TArray<bool>* EntriesEnabled, class FString* Fail_Reason, bool* Implemented)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "Get Available Options for Interacting WIth An Entry_CommonActorLogic");

	Params::StoredData_Embryo_Lib_C_Get_Available_Options_for_Interacting_WIth_An_Entry_CommonActorLogic Parms{};

	Parms.StoredData_Entry_Owner = StoredData_Entry_Owner;
	Parms.Remote_Actor_To_Transfer_To = Remote_Actor_To_Transfer_To;
	Parms.Entry_Index = Entry_Index;
	Parms.Actor_To_Call_Event_On = Actor_To_Call_Event_On;

	UObject::ProcessEvent(Func, &Parms);

	StoredData_Entry_Owner = Parms.StoredData_Entry_Owner;
	Entry_Index = Parms.Entry_Index;

	if (Entry_Options != nullptr)
		*Entry_Options = std::move(Parms.Entry_Options);

	if (EntriesEnabled != nullptr)
		*EntriesEnabled = std::move(Parms.EntriesEnabled);

	if (Fail_Reason != nullptr)
		*Fail_Reason = std::move(Parms.Fail_Reason);

	if (Implemented != nullptr)
		*Implemented = Parms.Implemented;
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.Get Unique Identifier For Entry
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Unique_ID                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::Get_Unique_Identifier_For_Entry(int32 Entry_Index, class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Fail_Reason_String, bool* success, double* Unique_ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "Get Unique Identifier For Entry");

	Params::StoredData_Embryo_Lib_C_Get_Unique_Identifier_For_Entry Parms{};

	Parms.Entry_Index = Entry_Index;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);

	if (success != nullptr)
		*success = Parms.success;

	if (Unique_ID != nullptr)
		*Unique_ID = Parms.Unique_ID;
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.GetCountOfStoredData
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimalItem*                      primal_item_target                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          fail_reason_string_count                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   succeeded_finding_count                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  found_count                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::GetCountOfStoredData(class AActor* Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class UPrimalItem* primal_item_target, class FString* fail_reason_string_count, bool* succeeded_finding_count, int32* found_count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "GetCountOfStoredData");

	Params::StoredData_Embryo_Lib_C_GetCountOfStoredData Parms{};

	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.primal_item_target = primal_item_target;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (fail_reason_string_count != nullptr)
		*fail_reason_string_count = std::move(Parms.fail_reason_string_count);

	if (succeeded_finding_count != nullptr)
		*succeeded_finding_count = Parms.succeeded_finding_count;

	if (found_count != nullptr)
		*found_count = Parms.found_count;
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.GetEmbryoDataAtEntryIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32&                                  StoredData_Index                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FEmbryoData*                     EmbryoData                                             (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::GetEmbryoDataAtEntryIndex(int32& StoredData_Index, class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, struct FEmbryoData* EmbryoData, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "GetEmbryoDataAtEntryIndex");

	Params::StoredData_Embryo_Lib_C_GetEmbryoDataAtEntryIndex Parms{};

	Parms.StoredData_Index = StoredData_Index;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	StoredData_Index = Parms.StoredData_Index;
	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (EmbryoData != nullptr)
		*EmbryoData = std::move(Parms.EmbryoData);

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.GetMaxAllowedStoredDataCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          ForActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String_B                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// int32*                                  max_allowed_count                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   succeeded_getting_max_allowed_count                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::GetMaxAllowedStoredDataCount(class AActor*& ForActor, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Fail_Reason_String_B, int32* max_allowed_count, bool* succeeded_getting_max_allowed_count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "GetMaxAllowedStoredDataCount");

	Params::StoredData_Embryo_Lib_C_GetMaxAllowedStoredDataCount Parms{};

	Parms.ForActor = ForActor;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	ForActor = Parms.ForActor;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Fail_Reason_String_B != nullptr)
		*Fail_Reason_String_B = std::move(Parms.Fail_Reason_String_B);

	if (max_allowed_count != nullptr)
		*max_allowed_count = Parms.max_allowed_count;

	if (succeeded_getting_max_allowed_count != nullptr)
		*succeeded_getting_max_allowed_count = Parms.succeeded_getting_max_allowed_count;
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.Interface_StoredData_GeneTrait_Optional_UI TriggerAvailable Options for Interacting WIth An Entry_0
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           StoredData_Entry_Owner                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Remote_Actor_To_Transfer_To                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// uint8                                   ChosenOption                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor_To_Call_Events_On                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::Interface_StoredData_GeneTrait_Optional_UI_TriggerAvailable_Options_for_Interacting_WIth_An_Entry_0(class AActor* StoredData_Entry_Owner, class AActor* Remote_Actor_To_Transfer_To, uint8 ChosenOption, int32 Entry_Index, class AActor* Actor_To_Call_Events_On, class FString* Fail_Reason, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "Interface_StoredData_GeneTrait_Optional_UI TriggerAvailable Options for Interacting WIth An Entry_0");

	Params::StoredData_Embryo_Lib_C_Interface_StoredData_GeneTrait_Optional_UI_TriggerAvailable_Options_for_Interacting_WIth_An_Entry_0 Parms{};

	Parms.StoredData_Entry_Owner = StoredData_Entry_Owner;
	Parms.Remote_Actor_To_Transfer_To = Remote_Actor_To_Transfer_To;
	Parms.ChosenOption = ChosenOption;
	Parms.Entry_Index = Entry_Index;
	Parms.Actor_To_Call_Events_On = Actor_To_Call_Events_On;

	UObject::ProcessEvent(Func, &Parms);

	if (Fail_Reason != nullptr)
		*Fail_Reason = std::move(Parms.Fail_Reason);

	if (success != nullptr)
		*success = Parms.success;
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.RemoveStoredDataEntry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   StoredDataIndex                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor_to_Remove_From                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          RequestedByActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::RemoveStoredDataEntry(struct FFunctionParams_NoArrays& Function_Params, int32 StoredDataIndex, class AActor* Actor_to_Remove_From, class FName& Function_Tag, class AActor*& RequestedByActor, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "RemoveStoredDataEntry");

	Params::StoredData_Embryo_Lib_C_RemoveStoredDataEntry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.StoredDataIndex = StoredDataIndex;
	Parms.Actor_to_Remove_From = Actor_to_Remove_From;
	Parms.Function_Tag = Function_Tag;
	Parms.RequestedByActor = RequestedByActor;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;
	RequestedByActor = Parms.RequestedByActor;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.Target Is Valid For transfer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          Target_To_Check                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    MustBeCreature                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeOnSameTeam                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeWild                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBePregnantCreature                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustNotBePregnantCreature                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeStructure                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeBabyCreature                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAdultCreature                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeFemale                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeMale                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAlive                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeDead                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             Must_Match_Specific_Class                              (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class AActor*&                          Valid_To_Whom                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             Must_Match_Specific_Dino_Entry_Class                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool*                                   IsValidToBeInteractedWith                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::Target_Is_Valid_For_transfer(class AActor*& Target_To_Check, class FName& Function_Tag, struct FFunctionParams_NoArrays& Function_Params, bool MustBeCreature, bool MustBeOnSameTeam, bool MustBeWild, bool MustBePregnantCreature, bool MustNotBePregnantCreature, bool MustBeStructure, bool MustBeBabyCreature, bool MustBeAdultCreature, bool MustBeFemale, bool MustBeMale, bool MustBeAlive, bool MustBeDead, TSoftClassPtr<class UClass> Must_Match_Specific_Class, class AActor*& Valid_To_Whom, TSoftClassPtr<class UClass> Must_Match_Specific_Dino_Entry_Class, bool* IsValidToBeInteractedWith, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "Target Is Valid For transfer");

	Params::StoredData_Embryo_Lib_C_Target_Is_Valid_For_transfer Parms{};

	Parms.Target_To_Check = Target_To_Check;
	Parms.Function_Tag = Function_Tag;
	Parms.Function_Params = std::move(Function_Params);
	Parms.MustBeCreature = MustBeCreature;
	Parms.MustBeOnSameTeam = MustBeOnSameTeam;
	Parms.MustBeWild = MustBeWild;
	Parms.MustBePregnantCreature = MustBePregnantCreature;
	Parms.MustNotBePregnantCreature = MustNotBePregnantCreature;
	Parms.MustBeStructure = MustBeStructure;
	Parms.MustBeBabyCreature = MustBeBabyCreature;
	Parms.MustBeAdultCreature = MustBeAdultCreature;
	Parms.MustBeFemale = MustBeFemale;
	Parms.MustBeMale = MustBeMale;
	Parms.MustBeAlive = MustBeAlive;
	Parms.MustBeDead = MustBeDead;
	Parms.Must_Match_Specific_Class = Must_Match_Specific_Class;
	Parms.Valid_To_Whom = Valid_To_Whom;
	Parms.Must_Match_Specific_Dino_Entry_Class = Must_Match_Specific_Dino_Entry_Class;

	UObject::ProcessEvent(Func, &Parms);

	Target_To_Check = Parms.Target_To_Check;
	Function_Tag = Parms.Function_Tag;
	Function_Params = std::move(Parms.Function_Params);
	Valid_To_Whom = Parms.Valid_To_Whom;

	if (IsValidToBeInteractedWith != nullptr)
		*IsValidToBeInteractedWith = Parms.IsValidToBeInteractedWith;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.UI Get Available Options For Interacting WIth An Entry
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   EntryIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Left_Target_Actor                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Right_Target_Actor                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Entry_Is_Held_By_Left_Target_Actor                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>*                  EntryOptions                                           (Parm, OutParm)
// TArray<bool>*                           EntryOptionsEnabled                                    (Parm, OutParm)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::UI_Get_Available_Options_For_Interacting_WIth_An_Entry(struct FFunctionParams_NoArrays& Function_Params, int32 EntryIndex, class FName Function_Tag, class AActor* Left_Target_Actor, class AActor* Right_Target_Actor, bool Entry_Is_Held_By_Left_Target_Actor, TArray<class FString>* EntryOptions, TArray<bool>* EntryOptionsEnabled, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "UI Get Available Options For Interacting WIth An Entry");

	Params::StoredData_Embryo_Lib_C_UI_Get_Available_Options_For_Interacting_WIth_An_Entry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.EntryIndex = EntryIndex;
	Parms.Function_Tag = Function_Tag;
	Parms.Left_Target_Actor = Left_Target_Actor;
	Parms.Right_Target_Actor = Right_Target_Actor;
	Parms.Entry_Is_Held_By_Left_Target_Actor = Entry_Is_Held_By_Left_Target_Actor;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);

	if (EntryOptions != nullptr)
		*EntryOptions = std::move(Parms.EntryOptions);

	if (EntryOptionsEnabled != nullptr)
		*EntryOptionsEnabled = std::move(Parms.EntryOptionsEnabled);

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.UI Trigger Option for Interacting WIth An Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   Option_Chosen                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Entry_Owning_Actor                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Remote_Actor_To_Transfer_To                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          fail_reason_string_for_triggering_entry_action         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   succeeded_triggering_entry_action                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::UI_Trigger_Option_for_Interacting_WIth_An_Entry(struct FFunctionParams_NoArrays& Function_Params, int32 Entry_Index, uint8 Option_Chosen, class FName& Function_Tag, class AActor* Entry_Owning_Actor, class AActor* Remote_Actor_To_Transfer_To, class FString* fail_reason_string_for_triggering_entry_action, bool* succeeded_triggering_entry_action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "UI Trigger Option for Interacting WIth An Entry");

	Params::StoredData_Embryo_Lib_C_UI_Trigger_Option_for_Interacting_WIth_An_Entry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Entry_Index = Entry_Index;
	Parms.Option_Chosen = Option_Chosen;
	Parms.Function_Tag = Function_Tag;
	Parms.Entry_Owning_Actor = Entry_Owning_Actor;
	Parms.Remote_Actor_To_Transfer_To = Remote_Actor_To_Transfer_To;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (fail_reason_string_for_triggering_entry_action != nullptr)
		*fail_reason_string_for_triggering_entry_action = std::move(Parms.fail_reason_string_for_triggering_entry_action);

	if (succeeded_triggering_entry_action != nullptr)
		*succeeded_triggering_entry_action = Parms.succeeded_triggering_entry_action;
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.UI_Get Description For PARTICULAR Entry
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32&                                  StoredData_Index                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Description_For_Entry                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::UI_Get_Description_For_PARTICULAR_Entry(int32& StoredData_Index, class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Description_For_Entry, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "UI_Get Description For PARTICULAR Entry");

	Params::StoredData_Embryo_Lib_C_UI_Get_Description_For_PARTICULAR_Entry Parms{};

	Parms.StoredData_Index = StoredData_Index;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	StoredData_Index = Parms.StoredData_Index;
	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Description_For_Entry != nullptr)
		*Description_For_Entry = std::move(Parms.Description_For_Entry);

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredData_Embryo_Lib.StoredData_Embryo_Lib_C.UI_Get Display Name For PARTICULAR Entry
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32&                                  StoredData_Index                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimalItem*                      primal_item_target                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          ret_name_for_particular_entry                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   succeeded_getting_name_for_particular_entry            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          ret_fail_reason_string_for_getting_name_of_particular_entry(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredData_Embryo_Lib_C::UI_Get_Display_Name_For_PARTICULAR_Entry(int32& StoredData_Index, class AActor* Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class UPrimalItem* primal_item_target, class FString* ret_name_for_particular_entry, bool* succeeded_getting_name_for_particular_entry, class FString* ret_fail_reason_string_for_getting_name_of_particular_entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredData_Embryo_Lib_C", "UI_Get Display Name For PARTICULAR Entry");

	Params::StoredData_Embryo_Lib_C_UI_Get_Display_Name_For_PARTICULAR_Entry Parms{};

	Parms.StoredData_Index = StoredData_Index;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.primal_item_target = primal_item_target;

	UObject::ProcessEvent(Func, &Parms);

	StoredData_Index = Parms.StoredData_Index;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (ret_name_for_particular_entry != nullptr)
		*ret_name_for_particular_entry = std::move(Parms.ret_name_for_particular_entry);

	if (succeeded_getting_name_for_particular_entry != nullptr)
		*succeeded_getting_name_for_particular_entry = Parms.succeeded_getting_name_for_particular_entry;

	if (ret_fail_reason_string_for_getting_name_of_particular_entry != nullptr)
		*ret_fail_reason_string_for_getting_name_of_particular_entry = std::move(Parms.ret_fail_reason_string_for_getting_name_of_particular_entry);
}

}

