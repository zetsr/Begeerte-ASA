#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayPseudoFunctionLibrary

#include "Basic.hpp"

#include "GameplayPseudoFunctionLibrary_classes.hpp"
#include "GameplayPseudoFunctionLibrary_parameters.hpp"


namespace SDK
{

// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Align World Rotation To Ground Normal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Impact_Normal                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  Original_World_Rot                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FVector&                   ActorForwardVector                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator*                        World_Rot_Aligned_To_Ground_Normal                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGameplayPseudoFunctionLibrary_C::Align_World_Rotation_To_Ground_Normal(const struct FVector& Impact_Normal, const struct FRotator& Original_World_Rot, const struct FVector& ActorForwardVector, struct FRotator* World_Rot_Aligned_To_Ground_Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Align World Rotation To Ground Normal");

	Params::GameplayPseudoFunctionLibrary_C_Align_World_Rotation_To_Ground_Normal Parms{};

	Parms.Impact_Normal = std::move(Impact_Normal);
	Parms.Original_World_Rot = std::move(Original_World_Rot);
	Parms.ActorForwardVector = std::move(ActorForwardVector);

	UObject::ProcessEvent(Func, &Parms);

	if (World_Rot_Aligned_To_Ground_Normal != nullptr)
		*World_Rot_Aligned_To_Ground_Normal = std::move(Parms.World_Rot_Aligned_To_Ground_Normal);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Are Tribes Allied
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   TribeID1                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TribeID2                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGameplayPseudoFunctionLibrary_C::Are_Tribes_Allied(int32 TribeID1, int32 TribeID2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Are Tribes Allied");

	Params::GameplayPseudoFunctionLibrary_C_Are_Tribes_Allied Parms{};

	Parms.TribeID1 = TribeID1;
	Parms.TribeID2 = TribeID2;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Copied- Find Vector Intercept Time
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Approacher_Velocity                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Intercept_Target_Relative_Position                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Intercept_Target_s_Velocity                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Intercept_Time                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Copied__Find_Vector_Intercept_Time(const struct FVector& Approacher_Velocity, const struct FVector& Intercept_Target_Relative_Position, const struct FVector& Intercept_Target_s_Velocity, double* Intercept_Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Copied- Find Vector Intercept Time");

	Params::GameplayPseudoFunctionLibrary_C_Copied__Find_Vector_Intercept_Time Parms{};

	Parms.Approacher_Velocity = std::move(Approacher_Velocity);
	Parms.Intercept_Target_Relative_Position = std::move(Intercept_Target_Relative_Position);
	Parms.Intercept_Target_s_Velocity = std::move(Intercept_Target_s_Velocity);

	UObject::ProcessEvent(Func, &Parms);

	if (Intercept_Time != nullptr)
		*Intercept_Time = Parms.Intercept_Time;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Copied-Clamp Vector Within Angle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Input_Angle                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Forward_Vector__Input_Clamped_Relative_To_This_        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Horizontal_Angle_Clamp                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  _not_implemented__Vertical_Angle_Clamp                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Clamped_Vector                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Was_Clamped_By_Horizontal_Restriction                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   _not_implemented__Was_Clamped_By_Vertical_Restriction  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Copied_Clamp_Vector_Within_Angle(const struct FVector& Input_Angle, const struct FVector& Forward_Vector__Input_Clamped_Relative_To_This_, double Horizontal_Angle_Clamp, double _not_implemented__Vertical_Angle_Clamp, struct FVector* Clamped_Vector, bool* Was_Clamped_By_Horizontal_Restriction, bool* _not_implemented__Was_Clamped_By_Vertical_Restriction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Copied-Clamp Vector Within Angle");

	Params::GameplayPseudoFunctionLibrary_C_Copied_Clamp_Vector_Within_Angle Parms{};

	Parms.Input_Angle = std::move(Input_Angle);
	Parms.Forward_Vector__Input_Clamped_Relative_To_This_ = std::move(Forward_Vector__Input_Clamped_Relative_To_This_);
	Parms.Horizontal_Angle_Clamp = Horizontal_Angle_Clamp;
	Parms._not_implemented__Vertical_Angle_Clamp = _not_implemented__Vertical_Angle_Clamp;

	UObject::ProcessEvent(Func, &Parms);

	if (Clamped_Vector != nullptr)
		*Clamped_Vector = std::move(Parms.Clamped_Vector);

	if (Was_Clamped_By_Horizontal_Restriction != nullptr)
		*Was_Clamped_By_Horizontal_Restriction = Parms.Was_Clamped_By_Horizontal_Restriction;

	if (_not_implemented__Was_Clamped_By_Vertical_Restriction != nullptr)
		*_not_implemented__Was_Clamped_By_Vertical_Restriction = Parms._not_implemented__Was_Clamped_By_Vertical_Restriction;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Copied-Find Closest Skin Position On Creature
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Loc_To_Check_From                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APrimalCharacter*                 Character_Who_s_Skin_Point_We_re_Finding               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName*                            Found_Closest_Socket                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         world_loc                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Copied_Find_Closest_Skin_Position_On_Creature(const struct FVector& Loc_To_Check_From, class APrimalCharacter* Character_Who_s_Skin_Point_We_re_Finding, bool* success, class FName* Found_Closest_Socket, struct FVector* world_loc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Copied-Find Closest Skin Position On Creature");

	Params::GameplayPseudoFunctionLibrary_C_Copied_Find_Closest_Skin_Position_On_Creature Parms{};

	Parms.Loc_To_Check_From = std::move(Loc_To_Check_From);
	Parms.Character_Who_s_Skin_Point_We_re_Finding = Character_Who_s_Skin_Point_We_re_Finding;

	UObject::ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;

	if (Found_Closest_Socket != nullptr)
		*Found_Closest_Socket = Parms.Found_Closest_Socket;

	if (world_loc != nullptr)
		*world_loc = std::move(Parms.world_loc);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Copied-Find Path To Destination WIth Clearance And Adjust Loc To Be Above Ground
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APrimalCharacter*                 Char                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Desired_Loc                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const bool                              Debug                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Max_Possible_Number_of_Alternate_Paths_To_Check        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Adjustment_Per_Blocking_Trace                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Max_Allowed_Height_Over_Blockers                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Adjusted_Move_Loc                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8*                                  Could_Fit_Result                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>*                 Finalized_Path                                         (Parm, OutParm)

void UGameplayPseudoFunctionLibrary_C::Copied_Find_Path_To_Destination_WIth_Clearance_And_Adjust_Loc_To_Be_Above_Ground(class APrimalCharacter* Char, const struct FVector& Desired_Loc, const bool Debug, int32 Max_Possible_Number_of_Alternate_Paths_To_Check, const struct FVector& Adjustment_Per_Blocking_Trace, double Max_Allowed_Height_Over_Blockers, struct FVector* Adjusted_Move_Loc, uint8* Could_Fit_Result, TArray<struct FVector>* Finalized_Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Copied-Find Path To Destination WIth Clearance And Adjust Loc To Be Above Ground");

	Params::GameplayPseudoFunctionLibrary_C_Copied_Find_Path_To_Destination_WIth_Clearance_And_Adjust_Loc_To_Be_Above_Ground Parms{};

	Parms.Char = Char;
	Parms.Desired_Loc = std::move(Desired_Loc);
	Parms.Debug = Debug;
	Parms.Max_Possible_Number_of_Alternate_Paths_To_Check = Max_Possible_Number_of_Alternate_Paths_To_Check;
	Parms.Adjustment_Per_Blocking_Trace = std::move(Adjustment_Per_Blocking_Trace);
	Parms.Max_Allowed_Height_Over_Blockers = Max_Allowed_Height_Over_Blockers;

	UObject::ProcessEvent(Func, &Parms);

	if (Adjusted_Move_Loc != nullptr)
		*Adjusted_Move_Loc = std::move(Parms.Adjusted_Move_Loc);

	if (Could_Fit_Result != nullptr)
		*Could_Fit_Result = Parms.Could_Fit_Result;

	if (Finalized_Path != nullptr)
		*Finalized_Path = std::move(Parms.Finalized_Path);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Copied-Is Target Loc Within Angle to Forward
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Actor_loc                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   target_pos                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Forward                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Angle                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Was_Within_Angle                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Copied_Is_Target_Loc_Within_Angle_to_Forward(const struct FVector& Actor_loc, const struct FVector& target_pos, const struct FVector& Forward, double Angle, bool* Was_Within_Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Copied-Is Target Loc Within Angle to Forward");

	Params::GameplayPseudoFunctionLibrary_C_Copied_Is_Target_Loc_Within_Angle_to_Forward Parms{};

	Parms.Actor_loc = std::move(Actor_loc);
	Parms.target_pos = std::move(target_pos);
	Parms.Forward = std::move(Forward);
	Parms.Angle = Angle;

	UObject::ProcessEvent(Func, &Parms);

	if (Was_Within_Angle != nullptr)
		*Was_Within_Angle = Parms.Was_Within_Angle;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Copied-requires enum merge-Get Adjusted Safe Loc for Setting Actor Location - From Capsule Bottom
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Char                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Desired_Loc                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const bool                              Debug                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Copied_requires_enum_merge_Get_Adjusted_Safe_Loc_for_Setting_Actor_Location___From_Capsule_Bottom(class UObject* Char, const struct FVector& Desired_Loc, const bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Copied-requires enum merge-Get Adjusted Safe Loc for Setting Actor Location - From Capsule Bottom");

	Params::GameplayPseudoFunctionLibrary_C_Copied_requires_enum_merge_Get_Adjusted_Safe_Loc_for_Setting_Actor_Location___From_Capsule_Bottom Parms{};

	Parms.Char = Char;
	Parms.Desired_Loc = std::move(Desired_Loc);
	Parms.Debug = Debug;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Create Sorted Path Of Actors By Distance
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>&                  ActorsArray                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FVector&                   OriginToDetectDistFrom                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>*                  SortedArray                                            (Parm, OutParm)

void UGameplayPseudoFunctionLibrary_C::Create_Sorted_Path_Of_Actors_By_Distance(TArray<class AActor*>& ActorsArray, const struct FVector& OriginToDetectDistFrom, TArray<class AActor*>* SortedArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Create Sorted Path Of Actors By Distance");

	Params::GameplayPseudoFunctionLibrary_C_Create_Sorted_Path_Of_Actors_By_Distance Parms{};

	Parms.ActorsArray = std::move(ActorsArray);
	Parms.OriginToDetectDistFrom = std::move(OriginToDetectDistFrom);

	UObject::ProcessEvent(Func, &Parms);

	ActorsArray = std::move(Parms.ActorsArray);

	if (SortedArray != nullptr)
		*SortedArray = std::move(Parms.SortedArray);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Create Sorted Path Of Actors By Distance_ButOnlyReachableByLaunching
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   OriginToDetectDistFrom                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>&                  ActorsArray                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double                                  Gravity                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<double>&                         MaxLaunchSpeeds                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class AActor*>*                  SortedArray                                            (Parm, OutParm)
// TArray<struct FVector>*                 LaunchDirections1                                      (Parm, OutParm)

void UGameplayPseudoFunctionLibrary_C::Create_Sorted_Path_Of_Actors_By_Distance_ButOnlyReachableByLaunching(const struct FVector& OriginToDetectDistFrom, TArray<class AActor*>& ActorsArray, double Gravity, TArray<double>& MaxLaunchSpeeds, TArray<class AActor*>* SortedArray, TArray<struct FVector>* LaunchDirections1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Create Sorted Path Of Actors By Distance_ButOnlyReachableByLaunching");

	Params::GameplayPseudoFunctionLibrary_C_Create_Sorted_Path_Of_Actors_By_Distance_ButOnlyReachableByLaunching Parms{};

	Parms.OriginToDetectDistFrom = std::move(OriginToDetectDistFrom);
	Parms.ActorsArray = std::move(ActorsArray);
	Parms.Gravity = Gravity;
	Parms.MaxLaunchSpeeds = std::move(MaxLaunchSpeeds);

	UObject::ProcessEvent(Func, &Parms);

	ActorsArray = std::move(Parms.ActorsArray);
	MaxLaunchSpeeds = std::move(Parms.MaxLaunchSpeeds);

	if (SortedArray != nullptr)
		*SortedArray = std::move(Parms.SortedArray);

	if (LaunchDirections1 != nullptr)
		*LaunchDirections1 = std::move(Parms.LaunchDirections1);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.DebugObstructedTraceResults
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    Debug_Enabled                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Forward                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ECollisionChannel                       Channel                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::DebugObstructedTraceResults(const struct FHitResult& Hit, bool Debug_Enabled, bool Forward, ECollisionChannel Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "DebugObstructedTraceResults");

	Params::GameplayPseudoFunctionLibrary_C_DebugObstructedTraceResults Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Debug_Enabled = Debug_Enabled;
	Parms.Forward = Forward;
	Parms.Channel = Channel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.DebugPrint
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FString&                    Line_1                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    Line_2                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    Line_3                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    Line_4                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// const class FString&                    Line_5                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::DebugPrint(const class FString& Line_1, const class FString& Line_2, const class FString& Line_3, const class FString& Line_4, const class FString& Line_5, bool Debug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "DebugPrint");

	Params::GameplayPseudoFunctionLibrary_C_DebugPrint Parms{};

	Parms.Line_1 = std::move(Line_1);
	Parms.Line_2 = std::move(Line_2);
	Parms.Line_3 = std::move(Line_3);
	Parms.Line_4 = std::move(Line_4);
	Parms.Line_5 = std::move(Line_5);
	Parms.Debug = Debug;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Decrease Float Value by Item Quality
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  OriginalValue                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Quality                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  InverseQualityMultiplier                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 ModifiedValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Decrease_Float_Value_by_Item_Quality(double OriginalValue, double Quality, double InverseQualityMultiplier, double* ModifiedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Decrease Float Value by Item Quality");

	Params::GameplayPseudoFunctionLibrary_C_Decrease_Float_Value_by_Item_Quality Parms{};

	Parms.OriginalValue = OriginalValue;
	Parms.Quality = Quality;
	Parms.InverseQualityMultiplier = InverseQualityMultiplier;

	UObject::ProcessEvent(Func, &Parms);

	if (ModifiedValue != nullptr)
		*ModifiedValue = Parms.ModifiedValue;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.get held direction relative to camera forward
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    allow_omni_directional_movement                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Move_Forward                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Move_Right                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   _Control_Direction                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UGameplayPseudoFunctionLibrary_C::get_held_direction_relative_to_camera_forward(bool allow_omni_directional_movement, double Move_Forward, double Move_Right, const struct FVector& _Control_Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "get held direction relative to camera forward");

	Params::GameplayPseudoFunctionLibrary_C_get_held_direction_relative_to_camera_forward Parms{};

	Parms.allow_omni_directional_movement = allow_omni_directional_movement;
	Parms.Move_Forward = Move_Forward;
	Parms.Move_Right = Move_Right;
	Parms._Control_Direction = std::move(_Control_Direction);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Get Player Held Direction In Worldspace
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Worldspace_Vector                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Get_Player_Held_Direction_In_Worldspace(class APawn* Pawn, struct FVector* Worldspace_Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Get Player Held Direction In Worldspace");

	Params::GameplayPseudoFunctionLibrary_C_Get_Player_Held_Direction_In_Worldspace Parms{};

	Parms.Pawn = Pawn;

	UObject::ProcessEvent(Func, &Parms);

	if (Worldspace_Vector != nullptr)
		*Worldspace_Vector = std::move(Parms.Worldspace_Vector);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Get World Rot Aligned To Ground
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Original_World_Loc                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  Original_World_Rot                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FVector&                   ActorForwardVector                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator*                        World_Rotation_Aligned_To_Ground_Normal                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult*                      TraceHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool*                                   Trace1hit                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Get_World_Rot_Aligned_To_Ground(const struct FVector& Original_World_Loc, const struct FRotator& Original_World_Rot, const struct FVector& ActorForwardVector, struct FRotator* World_Rotation_Aligned_To_Ground_Normal, struct FHitResult* TraceHitResult, bool* Trace1hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Get World Rot Aligned To Ground");

	Params::GameplayPseudoFunctionLibrary_C_Get_World_Rot_Aligned_To_Ground Parms{};

	Parms.Original_World_Loc = std::move(Original_World_Loc);
	Parms.Original_World_Rot = std::move(Original_World_Rot);
	Parms.ActorForwardVector = std::move(ActorForwardVector);

	UObject::ProcessEvent(Func, &Parms);

	if (World_Rotation_Aligned_To_Ground_Normal != nullptr)
		*World_Rotation_Aligned_To_Ground_Normal = std::move(Parms.World_Rotation_Aligned_To_Ground_Normal);

	if (TraceHitResult != nullptr)
		*TraceHitResult = std::move(Parms.TraceHitResult);

	if (Trace1hit != nullptr)
		*Trace1hit = Parms.Trace1hit;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Increase Float Value by Item Quality
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  OriginalValue                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Quality                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  InverseQualityMultiplier                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 ModifiedValue                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Increase_Float_Value_by_Item_Quality(double OriginalValue, double Quality, double InverseQualityMultiplier, double* ModifiedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Increase Float Value by Item Quality");

	Params::GameplayPseudoFunctionLibrary_C_Increase_Float_Value_by_Item_Quality Parms{};

	Parms.OriginalValue = OriginalValue;
	Parms.Quality = Quality;
	Parms.InverseQualityMultiplier = InverseQualityMultiplier;

	UObject::ProcessEvent(Func, &Parms);

	if (ModifiedValue != nullptr)
		*ModifiedValue = Parms.ModifiedValue;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.IsTargetValidToBeInteractedWith
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeOnSameTeam                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TargetingTeamToCheck                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RequiredDistance                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   DistanceCheckLocationFrom                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeCreature                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeWildCreature                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBePregnantCreature                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeNotPregnantCreature                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeBabyCreature                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAdultCreature                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeStructure                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeFemale                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeMale                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAlive                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeDead                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             Must_Match_Specific_Class                              (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             Must_Match_Specific_Dino_Entry_Class                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class AActor*                           WhoamTarget                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    MustNotBeOnSameTeam                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAlly__Includes_Teammates_                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAlly__Excludes_Teammates_                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeOnEnemyTeam                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsValidToBeInteractedWith                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::IsTargetValidToBeInteractedWith(class AActor* Target, bool MustBeOnSameTeam, int32 TargetingTeamToCheck, double RequiredDistance, const struct FVector& DistanceCheckLocationFrom, bool MustBeCreature, bool MustBeWildCreature, bool MustBePregnantCreature, bool MustBeNotPregnantCreature, bool MustBeBabyCreature, bool MustBeAdultCreature, bool MustBeStructure, bool MustBeFemale, bool MustBeMale, bool MustBeAlive, bool MustBeDead, TSoftClassPtr<class UClass> Must_Match_Specific_Class, TSoftClassPtr<class UClass> Must_Match_Specific_Dino_Entry_Class, class AActor* WhoamTarget, bool MustNotBeOnSameTeam, bool MustBeAlly__Includes_Teammates_, bool MustBeAlly__Excludes_Teammates_, bool MustBeOnEnemyTeam, bool* IsValidToBeInteractedWith, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "IsTargetValidToBeInteractedWith");

	Params::GameplayPseudoFunctionLibrary_C_IsTargetValidToBeInteractedWith Parms{};

	Parms.Target = Target;
	Parms.MustBeOnSameTeam = MustBeOnSameTeam;
	Parms.TargetingTeamToCheck = TargetingTeamToCheck;
	Parms.RequiredDistance = RequiredDistance;
	Parms.DistanceCheckLocationFrom = std::move(DistanceCheckLocationFrom);
	Parms.MustBeCreature = MustBeCreature;
	Parms.MustBeWildCreature = MustBeWildCreature;
	Parms.MustBePregnantCreature = MustBePregnantCreature;
	Parms.MustBeNotPregnantCreature = MustBeNotPregnantCreature;
	Parms.MustBeBabyCreature = MustBeBabyCreature;
	Parms.MustBeAdultCreature = MustBeAdultCreature;
	Parms.MustBeStructure = MustBeStructure;
	Parms.MustBeFemale = MustBeFemale;
	Parms.MustBeMale = MustBeMale;
	Parms.MustBeAlive = MustBeAlive;
	Parms.MustBeDead = MustBeDead;
	Parms.Must_Match_Specific_Class = Must_Match_Specific_Class;
	Parms.Must_Match_Specific_Dino_Entry_Class = Must_Match_Specific_Dino_Entry_Class;
	Parms.WhoamTarget = WhoamTarget;
	Parms.MustNotBeOnSameTeam = MustNotBeOnSameTeam;
	Parms.MustBeAlly__Includes_Teammates_ = MustBeAlly__Includes_Teammates_;
	Parms.MustBeAlly__Excludes_Teammates_ = MustBeAlly__Excludes_Teammates_;
	Parms.MustBeOnEnemyTeam = MustBeOnEnemyTeam;

	UObject::ProcessEvent(Func, &Parms);

	if (IsValidToBeInteractedWith != nullptr)
		*IsValidToBeInteractedWith = Parms.IsValidToBeInteractedWith;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.IsThereANonObstructedTraceToTheLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   StartingLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   DesiredLocation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceCapsuleRadius                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceCapsuleHalfHeight                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Debug_Trace_Duration                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   ThereIsAPath                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>*                 PathPointsIncludingStartAndEnd                         (Parm, OutParm)

void UGameplayPseudoFunctionLibrary_C::IsThereANonObstructedTraceToTheLocation(const struct FVector& StartingLocation, const struct FVector& DesiredLocation, double TraceCapsuleRadius, double TraceCapsuleHalfHeight, const TArray<class AActor*>& IgnoreActors, bool Debug, float Debug_Trace_Duration, bool* ThereIsAPath, TArray<struct FVector>* PathPointsIncludingStartAndEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "IsThereANonObstructedTraceToTheLocation");

	Params::GameplayPseudoFunctionLibrary_C_IsThereANonObstructedTraceToTheLocation Parms{};

	Parms.StartingLocation = std::move(StartingLocation);
	Parms.DesiredLocation = std::move(DesiredLocation);
	Parms.TraceCapsuleRadius = TraceCapsuleRadius;
	Parms.TraceCapsuleHalfHeight = TraceCapsuleHalfHeight;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Debug = Debug;
	Parms.Debug_Trace_Duration = Debug_Trace_Duration;

	UObject::ProcessEvent(Func, &Parms);

	if (ThereIsAPath != nullptr)
		*ThereIsAPath = Parms.ThereIsAPath;

	if (PathPointsIncludingStartAndEnd != nullptr)
		*PathPointsIncludingStartAndEnd = std::move(Parms.PathPointsIncludingStartAndEnd);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.IsThereANonObstructedTraceToTheLocation_ActualTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   StartingLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   DesiredLocation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceCapsuleRadius                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceCapsuleHalfHeight                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Debug_Trace_Duration                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ECollisionChannel                       Channel                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   ThereIsAPath                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::IsThereANonObstructedTraceToTheLocation_ActualTrace(const struct FVector& StartingLocation, const struct FVector& DesiredLocation, double TraceCapsuleRadius, double TraceCapsuleHalfHeight, const TArray<class AActor*>& IgnoreActors, bool Debug, float Debug_Trace_Duration, ECollisionChannel Channel, bool* ThereIsAPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "IsThereANonObstructedTraceToTheLocation_ActualTrace");

	Params::GameplayPseudoFunctionLibrary_C_IsThereANonObstructedTraceToTheLocation_ActualTrace Parms{};

	Parms.StartingLocation = std::move(StartingLocation);
	Parms.DesiredLocation = std::move(DesiredLocation);
	Parms.TraceCapsuleRadius = TraceCapsuleRadius;
	Parms.TraceCapsuleHalfHeight = TraceCapsuleHalfHeight;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Debug = Debug;
	Parms.Debug_Trace_Duration = Debug_Trace_Duration;
	Parms.Channel = Channel;

	UObject::ProcessEvent(Func, &Parms);

	if (ThereIsAPath != nullptr)
		*ThereIsAPath = Parms.ThereIsAPath;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.IsThereANonObstructedTraceToTheLocation_CheckVerticalVariations
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   OriginalLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   StartingLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   DesiredLocation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceCapsuleRadius                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceCapsuleHalfHeight                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Debug_Trace_Duration                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   ThereIsAPath                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>*                 PathPointsIncludingStartAndEnd                         (Parm, OutParm)

void UGameplayPseudoFunctionLibrary_C::IsThereANonObstructedTraceToTheLocation_CheckVerticalVariations(const struct FVector& OriginalLocation, const struct FVector& StartingLocation, const struct FVector& DesiredLocation, double TraceCapsuleRadius, double TraceCapsuleHalfHeight, const TArray<class AActor*>& IgnoreActors, bool Debug, float Debug_Trace_Duration, bool* ThereIsAPath, TArray<struct FVector>* PathPointsIncludingStartAndEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "IsThereANonObstructedTraceToTheLocation_CheckVerticalVariations");

	Params::GameplayPseudoFunctionLibrary_C_IsThereANonObstructedTraceToTheLocation_CheckVerticalVariations Parms{};

	Parms.OriginalLocation = std::move(OriginalLocation);
	Parms.StartingLocation = std::move(StartingLocation);
	Parms.DesiredLocation = std::move(DesiredLocation);
	Parms.TraceCapsuleRadius = TraceCapsuleRadius;
	Parms.TraceCapsuleHalfHeight = TraceCapsuleHalfHeight;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Debug = Debug;
	Parms.Debug_Trace_Duration = Debug_Trace_Duration;

	UObject::ProcessEvent(Func, &Parms);

	if (ThereIsAPath != nullptr)
		*ThereIsAPath = Parms.ThereIsAPath;

	if (PathPointsIncludingStartAndEnd != nullptr)
		*PathPointsIncludingStartAndEnd = std::move(Parms.PathPointsIncludingStartAndEnd);
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.IsThereANonObstructedTraceToTheLocation_IsThereANonObstructedTraceToTheLocation_VariousChannels
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   StartingLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   DesiredLocation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceCapsuleRadius                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceCapsuleHalfHeight                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<class AActor*>&            IgnoreActors                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Debug_Trace_Duration                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   ThereIsAPath                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::IsThereANonObstructedTraceToTheLocation_IsThereANonObstructedTraceToTheLocation_VariousChannels(const struct FVector& StartingLocation, const struct FVector& DesiredLocation, double TraceCapsuleRadius, double TraceCapsuleHalfHeight, const TArray<class AActor*>& IgnoreActors, bool Debug, float Debug_Trace_Duration, bool* ThereIsAPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "IsThereANonObstructedTraceToTheLocation_IsThereANonObstructedTraceToTheLocation_VariousChannels");

	Params::GameplayPseudoFunctionLibrary_C_IsThereANonObstructedTraceToTheLocation_IsThereANonObstructedTraceToTheLocation_VariousChannels Parms{};

	Parms.StartingLocation = std::move(StartingLocation);
	Parms.DesiredLocation = std::move(DesiredLocation);
	Parms.TraceCapsuleRadius = TraceCapsuleRadius;
	Parms.TraceCapsuleHalfHeight = TraceCapsuleHalfHeight;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.Debug = Debug;
	Parms.Debug_Trace_Duration = Debug_Trace_Duration;

	UObject::ProcessEvent(Func, &Parms);

	if (ThereIsAPath != nullptr)
		*ThereIsAPath = Parms.ThereIsAPath;
}


// Function GameplayPseudoFunctionLibrary.GameplayPseudoFunctionLibrary_C.Trace Check If On Ground
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   trace_origin                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool*                                   Hit                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameplayPseudoFunctionLibrary_C::Trace_Check_If_On_Ground(const struct FVector& trace_origin, struct FHitResult* OutHit, bool* Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayPseudoFunctionLibrary_C", "Trace Check If On Ground");

	Params::GameplayPseudoFunctionLibrary_C_Trace_Check_If_On_Ground Parms{};

	Parms.trace_origin = std::move(trace_origin);

	UObject::ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (Hit != nullptr)
		*Hit = Parms.Hit;
}

}

