#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TekBunker_FunctionLib

#include "Basic.hpp"

#include "TekBunker_FunctionLib_classes.hpp"
#include "TekBunker_FunctionLib_parameters.hpp"


namespace SDK
{

// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.ByteCoordinatesToVectorCoordinates
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<uint8>&                          Bytes                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector*                         CoordinatesVector                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::ByteCoordinatesToVectorCoordinates(TArray<uint8>& Bytes, struct FVector* CoordinatesVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "ByteCoordinatesToVectorCoordinates");

	Params::TekBunker_FunctionLib_C_ByteCoordinatesToVectorCoordinates Parms{};

	Parms.Bytes = std::move(Bytes);

	UObject::ProcessEvent(Func, &Parms);

	Bytes = std::move(Parms.Bytes);

	if (CoordinatesVector != nullptr)
		*CoordinatesVector = std::move(Parms.CoordinatesVector);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.ContainsAllStrings
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>&                  Strings                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const class FString&                    StringToCheck                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          RemainingString                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::ContainsAllStrings(TArray<class FString>& Strings, const class FString& StringToCheck, class FString* RemainingString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "ContainsAllStrings");

	Params::TekBunker_FunctionLib_C_ContainsAllStrings Parms{};

	Parms.Strings = std::move(Strings);
	Parms.StringToCheck = std::move(StringToCheck);

	UObject::ProcessEvent(Func, &Parms);

	Strings = std::move(Parms.Strings);

	if (RemainingString != nullptr)
		*RemainingString = std::move(Parms.RemainingString);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.FindVisibleWidget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UWidget*>&                 FromWidgets                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UWidget**                         VisibleWidget                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool*                                   FoundVisibleWidget                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::FindVisibleWidget(TArray<class UWidget*>& FromWidgets, class UWidget** VisibleWidget, bool* FoundVisibleWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "FindVisibleWidget");

	Params::TekBunker_FunctionLib_C_FindVisibleWidget Parms{};

	Parms.FromWidgets = std::move(FromWidgets);

	UObject::ProcessEvent(Func, &Parms);

	FromWidgets = std::move(Parms.FromWidgets);

	if (VisibleWidget != nullptr)
		*VisibleWidget = Parms.VisibleWidget;

	if (FoundVisibleWidget != nullptr)
		*FoundVisibleWidget = Parms.FoundVisibleWidget;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetActorClass
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass**                          Class_0                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetActorClass(class FName Name_0, class UClass** Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetActorClass");

	Params::TekBunker_FunctionLib_C_GetActorClass Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Class_0 != nullptr)
		*Class_0 = Parms.Class_0;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetCraftableAmountForItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UPrimalItem*                      Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimalInventoryComponent*        Inventory                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32*                                  CanCraftAmount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetCraftableAmountForItem(class UPrimalItem* Item, class UPrimalInventoryComponent* Inventory, int32* CanCraftAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetCraftableAmountForItem");

	Params::TekBunker_FunctionLib_C_GetCraftableAmountForItem Parms{};

	Parms.Item = Item;
	Parms.Inventory = Inventory;

	UObject::ProcessEvent(Func, &Parms);

	if (CanCraftAmount != nullptr)
		*CanCraftAmount = Parms.CanCraftAmount;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetDirectionFromVector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Vector                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName*                            Direction                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetDirectionFromVector(const struct FVector& Vector, class FName* Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetDirectionFromVector");

	Params::TekBunker_FunctionLib_C_GetDirectionFromVector Parms{};

	Parms.Vector = std::move(Vector);

	UObject::ProcessEvent(Func, &Parms);

	if (Direction != nullptr)
		*Direction = Parms.Direction;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetDirectlyAdjacentModuleCoordinates
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Coordinates                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>&                 ExistingModules                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FVector>*                 AdjacentModulesCoordinates                             (Parm, OutParm)

void UTekBunker_FunctionLib_C::GetDirectlyAdjacentModuleCoordinates(const struct FVector& Coordinates, TArray<struct FVector>& ExistingModules, TArray<struct FVector>* AdjacentModulesCoordinates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetDirectlyAdjacentModuleCoordinates");

	Params::TekBunker_FunctionLib_C_GetDirectlyAdjacentModuleCoordinates Parms{};

	Parms.Coordinates = std::move(Coordinates);
	Parms.ExistingModules = std::move(ExistingModules);

	UObject::ProcessEvent(Func, &Parms);

	ExistingModules = std::move(Parms.ExistingModules);

	if (AdjacentModulesCoordinates != nullptr)
		*AdjacentModulesCoordinates = std::move(Parms.AdjacentModulesCoordinates);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetDrillModID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int64*                                  modId                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetDrillModID(int64* modId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetDrillModID");

	Params::TekBunker_FunctionLib_C_GetDrillModID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (modId != nullptr)
		*modId = Parms.modId;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetJsonSettingKeys
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FString*                          UpgradeNameKey                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          DisabledTiersKey                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          EffectivenessMultipliersKey                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// class FString*                          UpgradeItemKey                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetJsonSettingKeys(class FString* UpgradeNameKey, class FString* DisabledTiersKey, class FString* EffectivenessMultipliersKey, class FString* UpgradeItemKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetJsonSettingKeys");

	Params::TekBunker_FunctionLib_C_GetJsonSettingKeys Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (UpgradeNameKey != nullptr)
		*UpgradeNameKey = std::move(Parms.UpgradeNameKey);

	if (DisabledTiersKey != nullptr)
		*DisabledTiersKey = std::move(Parms.DisabledTiersKey);

	if (EffectivenessMultipliersKey != nullptr)
		*EffectivenessMultipliersKey = std::move(Parms.EffectivenessMultipliersKey);

	if (UpgradeItemKey != nullptr)
		*UpgradeItemKey = std::move(Parms.UpgradeItemKey);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetLayoutCCA
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor**                          CCA                                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   CCAValid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetLayoutCCA(class AActor** CCA, bool* CCAValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetLayoutCCA");

	Params::TekBunker_FunctionLib_C_GetLayoutCCA Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CCA != nullptr)
		*CCA = Parms.CCA;

	if (CCAValid != nullptr)
		*CCAValid = Parms.CCAValid;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetOffsetFromDirection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Offset                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetOffsetFromDirection(class FName Direction, struct FVector* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetOffsetFromDirection");

	Params::TekBunker_FunctionLib_C_GetOffsetFromDirection Parms{};

	Parms.Direction = Direction;

	UObject::ProcessEvent(Func, &Parms);

	if (Offset != nullptr)
		*Offset = std::move(Parms.Offset);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetPlayerOwnsTekDrillOrLostColony
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APlayerController*                Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   OwnsEither                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetPlayerOwnsTekDrillOrLostColony(class APlayerController* Player, bool* OwnsEither)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetPlayerOwnsTekDrillOrLostColony");

	Params::TekBunker_FunctionLib_C_GetPlayerOwnsTekDrillOrLostColony Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (OwnsEither != nullptr)
		*OwnsEither = Parms.OwnsEither;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetPlayerOwnsTekDrillOrLostColonyAndShowPrompt
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   OwnsTekDrill                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetPlayerOwnsTekDrillOrLostColonyAndShowPrompt(class APlayerController* Player, bool* OwnsTekDrill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetPlayerOwnsTekDrillOrLostColonyAndShowPrompt");

	Params::TekBunker_FunctionLib_C_GetPlayerOwnsTekDrillOrLostColonyAndShowPrompt Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (OwnsTekDrill != nullptr)
		*OwnsTekDrill = Parms.OwnsTekDrill;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetTeamAllegiance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APrimalCharacter*                 Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherTeam                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   SameTribe                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Allies                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Enemies                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetTeamAllegiance(class APrimalCharacter* Character, int32 OtherTeam, bool* SameTribe, bool* Allies, bool* Enemies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetTeamAllegiance");

	Params::TekBunker_FunctionLib_C_GetTeamAllegiance Parms{};

	Parms.Character = Character;
	Parms.OtherTeam = OtherTeam;

	UObject::ProcessEvent(Func, &Parms);

	if (SameTribe != nullptr)
		*SameTribe = Parms.SameTribe;

	if (Allies != nullptr)
		*Allies = Parms.Allies;

	if (Enemies != nullptr)
		*Enemies = Parms.Enemies;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.GetTekDrillWidgetClass
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass**                          Class_0                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::GetTekDrillWidgetClass(class FName Name_0, class UClass** Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "GetTekDrillWidgetClass");

	Params::TekBunker_FunctionLib_C_GetTekDrillWidgetClass Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Class_0 != nullptr)
		*Class_0 = Parms.Class_0;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.IsActorObstruction
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// ECollisionChannel                       ForChannel                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsObstruction                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::IsActorObstruction(class AActor* Actor, class UPrimitiveComponent* Component, ECollisionChannel ForChannel, bool* IsObstruction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "IsActorObstruction");

	Params::TekBunker_FunctionLib_C_IsActorObstruction Parms{};

	Parms.Actor = Actor;
	Parms.Component = Component;
	Parms.ForChannel = ForChannel;

	UObject::ProcessEvent(Func, &Parms);

	if (IsObstruction != nullptr)
		*IsObstruction = Parms.IsObstruction;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.IsModuleWithinBounds
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   ModuleCoordinates                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   PositiveBounds                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   NegativeBounds                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   WithinBounds                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::IsModuleWithinBounds(const struct FVector& ModuleCoordinates, const struct FVector& PositiveBounds, const struct FVector& NegativeBounds, bool* WithinBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "IsModuleWithinBounds");

	Params::TekBunker_FunctionLib_C_IsModuleWithinBounds Parms{};

	Parms.ModuleCoordinates = std::move(ModuleCoordinates);
	Parms.PositiveBounds = std::move(PositiveBounds);
	Parms.NegativeBounds = std::move(NegativeBounds);

	UObject::ProcessEvent(Func, &Parms);

	if (WithinBounds != nullptr)
		*WithinBounds = Parms.WithinBounds;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.ModuleCoordinatesToOffsets
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Coordinates                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Offsets                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::ModuleCoordinatesToOffsets(const struct FVector& Coordinates, struct FVector* Offsets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "ModuleCoordinatesToOffsets");

	Params::TekBunker_FunctionLib_C_ModuleCoordinatesToOffsets Parms{};

	Parms.Coordinates = std::move(Coordinates);

	UObject::ProcessEvent(Func, &Parms);

	if (Offsets != nullptr)
		*Offsets = std::move(Parms.Offsets);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.ModuleCoordinatesToWorldLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Coordinates                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ForStructure                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         WorldLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::ModuleCoordinatesToWorldLocation(const struct FVector& Coordinates, class AActor* ForStructure, struct FVector* WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "ModuleCoordinatesToWorldLocation");

	Params::TekBunker_FunctionLib_C_ModuleCoordinatesToWorldLocation Parms{};

	Parms.Coordinates = std::move(Coordinates);
	Parms.ForStructure = ForStructure;

	UObject::ProcessEvent(Func, &Parms);

	if (WorldLocation != nullptr)
		*WorldLocation = std::move(Parms.WorldLocation);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.OffsetsToModuleCoordinates
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Offsets                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Coordinates                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::OffsetsToModuleCoordinates(const struct FVector& Offsets, struct FVector* Coordinates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "OffsetsToModuleCoordinates");

	Params::TekBunker_FunctionLib_C_OffsetsToModuleCoordinates Parms{};

	Parms.Offsets = std::move(Offsets);

	UObject::ProcessEvent(Func, &Parms);

	if (Coordinates != nullptr)
		*Coordinates = std::move(Parms.Coordinates);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.RealLocationToModuleCoordinates
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ForStructure                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         ModuleCoordinates                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsWithinBounds                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::RealLocationToModuleCoordinates(const struct FVector& Location, class AActor* ForStructure, struct FVector* ModuleCoordinates, bool* IsWithinBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "RealLocationToModuleCoordinates");

	Params::TekBunker_FunctionLib_C_RealLocationToModuleCoordinates Parms{};

	Parms.Location = std::move(Location);
	Parms.ForStructure = ForStructure;

	UObject::ProcessEvent(Func, &Parms);

	if (ModuleCoordinates != nullptr)
		*ModuleCoordinates = std::move(Parms.ModuleCoordinates);

	if (IsWithinBounds != nullptr)
		*IsWithinBounds = Parms.IsWithinBounds;
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.ShowPrompt
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UTekBunker_FunctionLib_C::ShowPrompt(class APlayerController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "ShowPrompt");

	Params::TekBunker_FunctionLib_C_ShowPrompt Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TekBunker_FunctionLib.TekBunker_FunctionLib_C.VectorCoordinatesToByteCoordinates
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   VectorCoordinates                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<uint8>*                          Bytes                                                  (Parm, OutParm)

void UTekBunker_FunctionLib_C::VectorCoordinatesToByteCoordinates(const struct FVector& VectorCoordinates, TArray<uint8>* Bytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TekBunker_FunctionLib_C", "VectorCoordinatesToByteCoordinates");

	Params::TekBunker_FunctionLib_C_VectorCoordinatesToByteCoordinates Parms{};

	Parms.VectorCoordinates = std::move(VectorCoordinates);

	UObject::ProcessEvent(Func, &Parms);

	if (Bytes != nullptr)
		*Bytes = std::move(Parms.Bytes);
}

}

