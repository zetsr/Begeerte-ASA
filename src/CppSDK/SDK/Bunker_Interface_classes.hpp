#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Bunker_Interface

#include "Basic.hpp"

#include "EDrillState_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass Bunker_Interface.Bunker_Interface_C
// 0x0000 (0x0000 - 0x0000)
class IBunker_Interface_C final
{
public:
	void Interface_AddModulesToPlacementBuffer(const TArray<struct FByteArray>& modules);
	void Interface_AddToTotalCraftedModulesQuantity(int32 ByQuantity);
	void Interface_AdminFillModules(bool StartPlacing);
	void Interface_CanTeleport(bool* CanTeleport);
	void Interface_CheckIfCanBeDemolished(class AShooterPlayerController* ForPC);
	void Interface_GetActualCraftableModuleAmount(bool Compute, int32* Amount, bool* CanCraft);
	void Interface_GetAllModuleDatas(TMap<struct FVector, struct FBunkerModuleData>* ModuleDatas);
	void Interface_GetAvailableLocations(TArray<struct FByteArray>* AvailableLocations, TArray<struct FByteArray>* BuiltLocations);
	void Interface_GetCanDemolish(bool* CanDemolish, class FString* CantDemolishReason);
	void Interface_GetDataForModules(TArray<struct FByteArray>& modules, TMap<struct FVector, struct FBunkerModuleData>* ModuleDatas);
	void Interface_GetDrillState(EDrillState* DrillState);
	void Interface_GetIsDestroying(bool* IsDestroying);
	void Interface_GetLevelSpawnOffset(struct FVector* SpawnOffset);
	void Interface_GetMainTerminal(class APrimalStructure** Terminal);
	void Interface_GetModuleDataForAllLayers(TArray<struct FBunkerModuleData>* ModuleDatas);
	void Interface_GetModuleQuantityData(int32* StoredModulesQuantity, int32* TotalCraftedQuantity, int32* RemainingAvailableCellQuantity, int32* ExistingModulesQuantity, int32* TotalAvailableCellQuantity, int32* CurrentlyPlacingModulesQuantity);
	void Interface_GetModules(TMap<struct FVector, class APrimalStructure*>* modules);
	void Interface_HasInitializedModuleData(bool* Initialized);
	void Interface_IsOwnerOfModule(const struct FVector& ModuleCoordinates, class APrimalStructure* Module, bool* IsOwner);
	void Interface_IsUnderHPThresholdToAccess(bool* IsUnderThreshold);
	void Interface_SetDataFromScan(const TArray<struct FByteArray>& AvailableLocations, const TArray<struct FByteArray>& UnavailableLocations);
	void Interface_SetDrillState(EDrillState DrillState);
	void Interface_TeleportPlayer(class AShooterPlayerController* Player, class APrimalStructure* FromTerminal, class APrimalDinoCharacter* RidingDino, bool TeleportBoth);
	void Interface_TeleportToLastModule(const class AShooterPlayerController* Player, class APrimalDinoCharacter* RidingDino);
	void Interface_TeleportToModule(const struct FVector& Coordinates, class AShooterPlayerController* Player, class APrimalDinoCharacter* RidingDino);
	void Interface_ToggleModuleTerminal(class AShooterPlayerController* ForPlayer, const TArray<uint8>& Coordinates);
	void Interface_TryRemoveModule(const TArray<uint8>& ModuleCoordinates, class AShooterPlayerController* PC);

public:
	static class UClass* StaticClass()
	{
		BP_STATIC_CLASS_IMPL("Bunker_Interface_C")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"Bunker_Interface_C")
	}
	static class IBunker_Interface_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBunker_Interface_C>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IBunker_Interface_C;

}

