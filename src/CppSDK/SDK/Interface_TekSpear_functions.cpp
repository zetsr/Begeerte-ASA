#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Interface_TekSpear

#include "Basic.hpp"

#include "Interface_TekSpear_classes.hpp"
#include "Interface_TekSpear_parameters.hpp"


namespace SDK
{

// Function Interface_TekSpear.Interface_TekSpear_C.Interface_ProjSpear_Tek get damage multiplier for attack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   attack_index                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 damage_multiplier                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_ProjSpear_Tek_get_damage_multiplier_for_attack(uint8 attack_index, double* damage_multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_ProjSpear_Tek get damage multiplier for attack");

	Params::Interface_TekSpear_C_Interface_ProjSpear_Tek_get_damage_multiplier_for_attack Parms{};

	Parms.attack_index = attack_index;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (damage_multiplier != nullptr)
		*damage_multiplier = Parms.damage_multiplier;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_ProjSpear_Tek get rotation towards projectile
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator*                        out_rotation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void IInterface_TekSpear_C::Interface_ProjSpear_Tek_get_rotation_towards_projectile(struct FRotator* out_rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_ProjSpear_Tek get rotation towards projectile");

	Params::Interface_TekSpear_C_Interface_ProjSpear_Tek_get_rotation_towards_projectile Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (out_rotation != nullptr)
		*out_rotation = std::move(Parms.out_rotation);
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_ProjSpear_Tek set projectile location
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Last_Projectile_Location                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_ProjSpear_Tek_set_projectile_location(const struct FVector& Last_Projectile_Location, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_ProjSpear_Tek set projectile location");

	Params::Interface_TekSpear_C_Interface_ProjSpear_Tek_set_projectile_location Parms{};

	Parms.Last_Projectile_Location = std::move(Last_Projectile_Location);

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_ProjSpear_Tek set rotation towards projectile
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FRotator&                  in_rot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_ProjSpear_Tek_set_rotation_towards_projectile(const struct FRotator& in_rot, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_ProjSpear_Tek set rotation towards projectile");

	Params::Interface_TekSpear_C_Interface_ProjSpear_Tek_set_rotation_towards_projectile Parms{};

	Parms.in_rot = std::move(in_rot);

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Destroy Projectile
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Destroy_Projectile(bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Destroy Projectile");

	Params::Interface_TekSpear_C_Interface_TekSpear__Destroy_Projectile Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Get Animations
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_WeapAnimWith3P_V3*       Attack_1                                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Attack_2                                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Attack_3                                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Held_Blocking_Loop                                     (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Block_Recoil                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Perfect_Block                                          (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Held_Deflecting_Loop                                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Deflect_Recoil                                         (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Perfect_Deflect                                        (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Dodge                                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Held_Air_Stab_Charge_Loop                              (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Air_Stab_Release                                       (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Ground_Slam_Falling_Loop                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Ground_Slam_Land                                       (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Held_Spear_Toss_Pullback_Loop                          (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Teleport_To_Spear_Midair                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Teleport_To_Spear_Grounded                             (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FStruct_WeapAnimWith3P_V3*       Fallback_Standard_Stab_like_in_water                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Get_Animations(struct FStruct_WeapAnimWith3P_V3* Attack_1, struct FStruct_WeapAnimWith3P_V3* Attack_2, struct FStruct_WeapAnimWith3P_V3* Attack_3, struct FStruct_WeapAnimWith3P_V3* Held_Blocking_Loop, struct FStruct_WeapAnimWith3P_V3* Block_Recoil, struct FStruct_WeapAnimWith3P_V3* Perfect_Block, struct FStruct_WeapAnimWith3P_V3* Held_Deflecting_Loop, struct FStruct_WeapAnimWith3P_V3* Deflect_Recoil, struct FStruct_WeapAnimWith3P_V3* Perfect_Deflect, struct FStruct_WeapAnimWith3P_V3* Dodge, struct FStruct_WeapAnimWith3P_V3* Held_Air_Stab_Charge_Loop, struct FStruct_WeapAnimWith3P_V3* Air_Stab_Release, struct FStruct_WeapAnimWith3P_V3* Ground_Slam_Falling_Loop, struct FStruct_WeapAnimWith3P_V3* Ground_Slam_Land, struct FStruct_WeapAnimWith3P_V3* Held_Spear_Toss_Pullback_Loop, struct FStruct_WeapAnimWith3P_V3* Teleport_To_Spear_Midair, struct FStruct_WeapAnimWith3P_V3* Teleport_To_Spear_Grounded, struct FStruct_WeapAnimWith3P_V3* Fallback_Standard_Stab_like_in_water)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Get Animations");

	Params::Interface_TekSpear_C_Interface_TekSpear__Get_Animations Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Attack_1 != nullptr)
		*Attack_1 = std::move(Parms.Attack_1);

	if (Attack_2 != nullptr)
		*Attack_2 = std::move(Parms.Attack_2);

	if (Attack_3 != nullptr)
		*Attack_3 = std::move(Parms.Attack_3);

	if (Held_Blocking_Loop != nullptr)
		*Held_Blocking_Loop = std::move(Parms.Held_Blocking_Loop);

	if (Block_Recoil != nullptr)
		*Block_Recoil = std::move(Parms.Block_Recoil);

	if (Perfect_Block != nullptr)
		*Perfect_Block = std::move(Parms.Perfect_Block);

	if (Held_Deflecting_Loop != nullptr)
		*Held_Deflecting_Loop = std::move(Parms.Held_Deflecting_Loop);

	if (Deflect_Recoil != nullptr)
		*Deflect_Recoil = std::move(Parms.Deflect_Recoil);

	if (Perfect_Deflect != nullptr)
		*Perfect_Deflect = std::move(Parms.Perfect_Deflect);

	if (Dodge != nullptr)
		*Dodge = std::move(Parms.Dodge);

	if (Held_Air_Stab_Charge_Loop != nullptr)
		*Held_Air_Stab_Charge_Loop = std::move(Parms.Held_Air_Stab_Charge_Loop);

	if (Air_Stab_Release != nullptr)
		*Air_Stab_Release = std::move(Parms.Air_Stab_Release);

	if (Ground_Slam_Falling_Loop != nullptr)
		*Ground_Slam_Falling_Loop = std::move(Parms.Ground_Slam_Falling_Loop);

	if (Ground_Slam_Land != nullptr)
		*Ground_Slam_Land = std::move(Parms.Ground_Slam_Land);

	if (Held_Spear_Toss_Pullback_Loop != nullptr)
		*Held_Spear_Toss_Pullback_Loop = std::move(Parms.Held_Spear_Toss_Pullback_Loop);

	if (Teleport_To_Spear_Midair != nullptr)
		*Teleport_To_Spear_Midair = std::move(Parms.Teleport_To_Spear_Midair);

	if (Teleport_To_Spear_Grounded != nullptr)
		*Teleport_To_Spear_Grounded = std::move(Parms.Teleport_To_Spear_Grounded);

	if (Fallback_Standard_Stab_like_in_water != nullptr)
		*Fallback_Standard_Stab_like_in_water = std::move(Parms.Fallback_Standard_Stab_like_in_water);
}


// Function Interface_TekSpear.Interface_TekSpear_C.Torp Mode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Is_Damage_Mode                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Is_Tranq_Mode                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Torp_Mode_0(bool* Is_Damage_Mode, bool* Is_Tranq_Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Torp Mode");

	Params::Interface_TekSpear_C_Torp_Mode_0 Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Is_Damage_Mode != nullptr)
		*Is_Damage_Mode = Parms.Is_Damage_Mode;

	if (Is_Tranq_Mode != nullptr)
		*Is_Tranq_Mode = Parms.Is_Tranq_Mode;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Get Ground Slam Final Hit dmg types
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UClass**                          Regular_dmg_type                                       (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UClass**                          torpor_dmg_type                                        (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Get_Ground_Slam_Final_Hit_dmg_types(class UClass** Regular_dmg_type, class UClass** torpor_dmg_type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Get Ground Slam Final Hit dmg types");

	Params::Interface_TekSpear_C_Interface_TekSpear__Get_Ground_Slam_Final_Hit_dmg_types Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Regular_dmg_type != nullptr)
		*Regular_dmg_type = Parms.Regular_dmg_type;

	if (torpor_dmg_type != nullptr)
		*torpor_dmg_type = Parms.torpor_dmg_type;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Get Midair Attack Air Limit Used
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Get_Midair_Attack_Air_Limit_Used(bool* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Get Midair Attack Air Limit Used");

	Params::Interface_TekSpear_C_Interface_TekSpear__Get_Midair_Attack_Air_Limit_Used Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Is Spear Projectile Valid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Is_Valid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AShooterProjectile**              Projectile_Ref                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Is_Spear_Projectile_Valid(bool* Is_Valid, class AShooterProjectile** Projectile_Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Is Spear Projectile Valid");

	Params::Interface_TekSpear_C_Interface_TekSpear__Is_Spear_Projectile_Valid Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Is_Valid != nullptr)
		*Is_Valid = Parms.Is_Valid;

	if (Projectile_Ref != nullptr)
		*Projectile_Ref = Parms.Projectile_Ref;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Torp Mode
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    _torpor                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Torp_Mode(bool _torpor, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Torp Mode");

	Params::Interface_TekSpear_C_Torp_Mode Parms{};

	Parms._torpor = _torpor;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Set Dynamic Material Parameters
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*         Material                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Set_Dynamic_Material_Parameters(class UMaterialInstanceDynamic* Material, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Set Dynamic Material Parameters");

	Params::Interface_TekSpear_C_Interface_TekSpear__Set_Dynamic_Material_Parameters Parms{};

	Parms.Material = Material;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Set Midair Attack Air Limit Used
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Value_To_Set                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Set_Midair_Attack_Air_Limit_Used(bool Value_To_Set, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Set Midair Attack Air Limit Used");

	Params::Interface_TekSpear_C_Interface_TekSpear__Set_Midair_Attack_Air_Limit_Used Parms{};

	Parms.Value_To_Set = Value_To_Set;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Set Parameters On Cascade VFX particles
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UParticleSystemComponent*         Cascade_VFX                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Set_Parameters_On_Cascade_VFX_particles(class UParticleSystemComponent* Cascade_VFX, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Set Parameters On Cascade VFX particles");

	Params::Interface_TekSpear_C_Interface_TekSpear__Set_Parameters_On_Cascade_VFX_particles Parms{};

	Parms.Cascade_VFX = Cascade_VFX;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_ Set Parameters On Niagara VFX particles
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UNiagaraComponent*                Niagara_VFX                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear__Set_Parameters_On_Niagara_VFX_particles(class UNiagaraComponent* Niagara_VFX, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_ Set Parameters On Niagara VFX particles");

	Params::Interface_TekSpear_C_Interface_TekSpear__Set_Parameters_On_Niagara_VFX_particles Parms{};

	Parms.Niagara_VFX = Niagara_VFX;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_CanSetWeaponStateTo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   DesiredWeaponState                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   CanSet                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName*                            Fail_Reason                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_CanSetWeaponStateTo(uint8 DesiredWeaponState, bool* CanSet, class FName* Fail_Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_CanSetWeaponStateTo");

	Params::Interface_TekSpear_C_Interface_TekSpear_CanSetWeaponStateTo Parms{};

	Parms.DesiredWeaponState = DesiredWeaponState;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CanSet != nullptr)
		*CanSet = Parms.CanSet;

	if (Fail_Reason != nullptr)
		*Fail_Reason = Parms.Fail_Reason;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_GetFakeExpandedScale
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double*                                 FakeExpandedScale                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_GetFakeExpandedScale(double* FakeExpandedScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_GetFakeExpandedScale");

	Params::Interface_TekSpear_C_Interface_TekSpear_GetFakeExpandedScale Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (FakeExpandedScale != nullptr)
		*FakeExpandedScale = Parms.FakeExpandedScale;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_GetLastLocationProjectileWasAt
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector*                         Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_GetLastLocationProjectileWasAt(struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_GetLastLocationProjectileWasAt");

	Params::Interface_TekSpear_C_Interface_TekSpear_GetLastLocationProjectileWasAt Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_GetLastSelectedTeleportSpot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsLastTPLocationAvailable                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         LastTPLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_GetLastSelectedTeleportSpot(bool* IsLastTPLocationAvailable, struct FVector* LastTPLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_GetLastSelectedTeleportSpot");

	Params::Interface_TekSpear_C_Interface_TekSpear_GetLastSelectedTeleportSpot Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsLastTPLocationAvailable != nullptr)
		*IsLastTPLocationAvailable = Parms.IsLastTPLocationAvailable;

	if (LastTPLocation != nullptr)
		*LastTPLocation = std::move(Parms.LastTPLocation);
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_GetState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8*                                  CurrentState                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   pullback                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   is_midair_stab_charging                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   is_midair_stab_releasing                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsBlocking                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsDoding                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsDeflecting                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_GetState(uint8* CurrentState, bool* pullback, bool* is_midair_stab_charging, bool* is_midair_stab_releasing, bool* IsBlocking, bool* IsDoding, bool* IsDeflecting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_GetState");

	Params::Interface_TekSpear_C_Interface_TekSpear_GetState Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CurrentState != nullptr)
		*CurrentState = Parms.CurrentState;

	if (pullback != nullptr)
		*pullback = Parms.pullback;

	if (is_midair_stab_charging != nullptr)
		*is_midair_stab_charging = Parms.is_midair_stab_charging;

	if (is_midair_stab_releasing != nullptr)
		*is_midair_stab_releasing = Parms.is_midair_stab_releasing;

	if (IsBlocking != nullptr)
		*IsBlocking = Parms.IsBlocking;

	if (IsDoding != nullptr)
		*IsDoding = Parms.IsDoding;

	if (IsDeflecting != nullptr)
		*IsDeflecting = Parms.IsDeflecting;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_GetThrownSpearProjRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Fround_Valid_Proj                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AShooterProjectile**              Spear_Ref                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_GetThrownSpearProjRef(bool* Fround_Valid_Proj, class AShooterProjectile** Spear_Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_GetThrownSpearProjRef");

	Params::Interface_TekSpear_C_Interface_TekSpear_GetThrownSpearProjRef Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Fround_Valid_Proj != nullptr)
		*Fround_Valid_Proj = Parms.Fround_Valid_Proj;

	if (Spear_Ref != nullptr)
		*Spear_Ref = Parms.Spear_Ref;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_GetWantsToBlock
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   WantsToBlock                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_GetWantsToBlock(bool* WantsToBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_GetWantsToBlock");

	Params::Interface_TekSpear_C_Interface_TekSpear_GetWantsToBlock Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (WantsToBlock != nullptr)
		*WantsToBlock = Parms.WantsToBlock;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_SetHideWeapon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    HiddenState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_SetHideWeapon(bool HiddenState, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_SetHideWeapon");

	Params::Interface_TekSpear_C_Interface_TekSpear_SetHideWeapon Parms{};

	Parms.HiddenState = HiddenState;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_SetLastLocationProjectileWasAt
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_SetLastLocationProjectileWasAt(const struct FVector& Location, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_SetLastLocationProjectileWasAt");

	Params::Interface_TekSpear_C_Interface_TekSpear_SetLastLocationProjectileWasAt Parms{};

	Parms.Location = std::move(Location);

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}


// Function Interface_TekSpear.Interface_TekSpear_C.Interface_TekSpear_SetLastSelectedTeleportSpot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   TeleportSpot                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IInterface_TekSpear_C::Interface_TekSpear_SetLastSelectedTeleportSpot(const struct FVector& TeleportSpot, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Interface_TekSpear_C", "Interface_TekSpear_SetLastSelectedTeleportSpot");

	Params::Interface_TekSpear_C_Interface_TekSpear_SetLastSelectedTeleportSpot Parms{};

	Parms.TeleportSpot = std::move(TeleportSpot);

	AsUObject()->ProcessEvent(Func, &Parms);

	if (success != nullptr)
		*success = Parms.success;
}

}

