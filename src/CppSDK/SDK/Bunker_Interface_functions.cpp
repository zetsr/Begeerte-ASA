#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Bunker_Interface

#include "Basic.hpp"

#include "Bunker_Interface_classes.hpp"
#include "Bunker_Interface_parameters.hpp"


namespace SDK
{

// Function Bunker_Interface.Bunker_Interface_C.Interface_AddModulesToPlacementBuffer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FByteArray>&        modules                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void IBunker_Interface_C::Interface_AddModulesToPlacementBuffer(const TArray<struct FByteArray>& modules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_AddModulesToPlacementBuffer");

	Params::Bunker_Interface_C_Interface_AddModulesToPlacementBuffer Parms{};

	Parms.modules = std::move(modules);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_AddToTotalCraftedModulesQuantity
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ByQuantity                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_AddToTotalCraftedModulesQuantity(int32 ByQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_AddToTotalCraftedModulesQuantity");

	Params::Bunker_Interface_C_Interface_AddToTotalCraftedModulesQuantity Parms{};

	Parms.ByQuantity = ByQuantity;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_AdminFillModules
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    StartPlacing                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_AdminFillModules(bool StartPlacing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_AdminFillModules");

	Params::Bunker_Interface_C_Interface_AdminFillModules Parms{};

	Parms.StartPlacing = StartPlacing;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_CanTeleport
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   CanTeleport                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_CanTeleport(bool* CanTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_CanTeleport");

	Params::Bunker_Interface_C_Interface_CanTeleport Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CanTeleport != nullptr)
		*CanTeleport = Parms.CanTeleport;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_CheckIfCanBeDemolished
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AShooterPlayerController*         ForPC                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_CheckIfCanBeDemolished(class AShooterPlayerController* ForPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_CheckIfCanBeDemolished");

	Params::Bunker_Interface_C_Interface_CheckIfCanBeDemolished Parms{};

	Parms.ForPC = ForPC;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetActualCraftableModuleAmount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Compute                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Amount                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   CanCraft                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_GetActualCraftableModuleAmount(bool Compute, int32* Amount, bool* CanCraft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetActualCraftableModuleAmount");

	Params::Bunker_Interface_C_Interface_GetActualCraftableModuleAmount Parms{};

	Parms.Compute = Compute;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Amount != nullptr)
		*Amount = Parms.Amount;

	if (CanCraft != nullptr)
		*CanCraft = Parms.CanCraft;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetAllModuleDatas
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<struct FVector, struct FBunkerModuleData>*ModuleDatas                                            (Parm, OutParm)

void IBunker_Interface_C::Interface_GetAllModuleDatas(TMap<struct FVector, struct FBunkerModuleData>* ModuleDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetAllModuleDatas");

	Params::Bunker_Interface_C_Interface_GetAllModuleDatas Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (ModuleDatas != nullptr)
		*ModuleDatas = std::move(Parms.ModuleDatas);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetAvailableLocations
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FByteArray>*              AvailableLocations                                     (Parm, OutParm)
// TArray<struct FByteArray>*              BuiltLocations                                         (Parm, OutParm)

void IBunker_Interface_C::Interface_GetAvailableLocations(TArray<struct FByteArray>* AvailableLocations, TArray<struct FByteArray>* BuiltLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetAvailableLocations");

	Params::Bunker_Interface_C_Interface_GetAvailableLocations Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (AvailableLocations != nullptr)
		*AvailableLocations = std::move(Parms.AvailableLocations);

	if (BuiltLocations != nullptr)
		*BuiltLocations = std::move(Parms.BuiltLocations);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetCanDemolish
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   CanDemolish                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          CantDemolishReason                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_GetCanDemolish(bool* CanDemolish, class FString* CantDemolishReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetCanDemolish");

	Params::Bunker_Interface_C_Interface_GetCanDemolish Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CanDemolish != nullptr)
		*CanDemolish = Parms.CanDemolish;

	if (CantDemolishReason != nullptr)
		*CantDemolishReason = std::move(Parms.CantDemolishReason);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetDataForModules
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FByteArray>&              modules                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TMap<struct FVector, struct FBunkerModuleData>*ModuleDatas                                            (Parm, OutParm)

void IBunker_Interface_C::Interface_GetDataForModules(TArray<struct FByteArray>& modules, TMap<struct FVector, struct FBunkerModuleData>* ModuleDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetDataForModules");

	Params::Bunker_Interface_C_Interface_GetDataForModules Parms{};

	Parms.modules = std::move(modules);

	AsUObject()->ProcessEvent(Func, &Parms);

	modules = std::move(Parms.modules);

	if (ModuleDatas != nullptr)
		*ModuleDatas = std::move(Parms.ModuleDatas);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetDrillState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EDrillState*                            DrillState                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_GetDrillState(EDrillState* DrillState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetDrillState");

	Params::Bunker_Interface_C_Interface_GetDrillState Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (DrillState != nullptr)
		*DrillState = Parms.DrillState;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetIsDestroying
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsDestroying                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_GetIsDestroying(bool* IsDestroying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetIsDestroying");

	Params::Bunker_Interface_C_Interface_GetIsDestroying Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsDestroying != nullptr)
		*IsDestroying = Parms.IsDestroying;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetLevelSpawnOffset
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector*                         SpawnOffset                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_GetLevelSpawnOffset(struct FVector* SpawnOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetLevelSpawnOffset");

	Params::Bunker_Interface_C_Interface_GetLevelSpawnOffset Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (SpawnOffset != nullptr)
		*SpawnOffset = std::move(Parms.SpawnOffset);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetMainTerminal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APrimalStructure**                Terminal                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_GetMainTerminal(class APrimalStructure** Terminal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetMainTerminal");

	Params::Bunker_Interface_C_Interface_GetMainTerminal Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Terminal != nullptr)
		*Terminal = Parms.Terminal;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetModuleDataForAllLayers
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FBunkerModuleData>*       ModuleDatas                                            (Parm, OutParm)

void IBunker_Interface_C::Interface_GetModuleDataForAllLayers(TArray<struct FBunkerModuleData>* ModuleDatas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetModuleDataForAllLayers");

	Params::Bunker_Interface_C_Interface_GetModuleDataForAllLayers Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (ModuleDatas != nullptr)
		*ModuleDatas = std::move(Parms.ModuleDatas);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetModuleQuantityData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  StoredModulesQuantity                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  TotalCraftedQuantity                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  RemainingAvailableCellQuantity                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  ExistingModulesQuantity                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  TotalAvailableCellQuantity                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  CurrentlyPlacingModulesQuantity                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_GetModuleQuantityData(int32* StoredModulesQuantity, int32* TotalCraftedQuantity, int32* RemainingAvailableCellQuantity, int32* ExistingModulesQuantity, int32* TotalAvailableCellQuantity, int32* CurrentlyPlacingModulesQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetModuleQuantityData");

	Params::Bunker_Interface_C_Interface_GetModuleQuantityData Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (StoredModulesQuantity != nullptr)
		*StoredModulesQuantity = Parms.StoredModulesQuantity;

	if (TotalCraftedQuantity != nullptr)
		*TotalCraftedQuantity = Parms.TotalCraftedQuantity;

	if (RemainingAvailableCellQuantity != nullptr)
		*RemainingAvailableCellQuantity = Parms.RemainingAvailableCellQuantity;

	if (ExistingModulesQuantity != nullptr)
		*ExistingModulesQuantity = Parms.ExistingModulesQuantity;

	if (TotalAvailableCellQuantity != nullptr)
		*TotalAvailableCellQuantity = Parms.TotalAvailableCellQuantity;

	if (CurrentlyPlacingModulesQuantity != nullptr)
		*CurrentlyPlacingModulesQuantity = Parms.CurrentlyPlacingModulesQuantity;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_GetModules
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TMap<struct FVector, class APrimalStructure*>*modules                                                (Parm, OutParm)

void IBunker_Interface_C::Interface_GetModules(TMap<struct FVector, class APrimalStructure*>* modules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_GetModules");

	Params::Bunker_Interface_C_Interface_GetModules Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (modules != nullptr)
		*modules = std::move(Parms.modules);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_HasInitializedModuleData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   Initialized                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_HasInitializedModuleData(bool* Initialized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_HasInitializedModuleData");

	Params::Bunker_Interface_C_Interface_HasInitializedModuleData Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (Initialized != nullptr)
		*Initialized = Parms.Initialized;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_IsOwnerOfModule
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   ModuleCoordinates                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APrimalStructure*                 Module                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsOwner                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_IsOwnerOfModule(const struct FVector& ModuleCoordinates, class APrimalStructure* Module, bool* IsOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_IsOwnerOfModule");

	Params::Bunker_Interface_C_Interface_IsOwnerOfModule Parms{};

	Parms.ModuleCoordinates = std::move(ModuleCoordinates);
	Parms.Module = Module;

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsOwner != nullptr)
		*IsOwner = Parms.IsOwner;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_IsUnderHPThresholdToAccess
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   IsUnderThreshold                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_IsUnderHPThresholdToAccess(bool* IsUnderThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_IsUnderHPThresholdToAccess");

	Params::Bunker_Interface_C_Interface_IsUnderHPThresholdToAccess Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (IsUnderThreshold != nullptr)
		*IsUnderThreshold = Parms.IsUnderThreshold;
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_SetDataFromScan
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FByteArray>&        AvailableLocations                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const TArray<struct FByteArray>&        UnavailableLocations                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void IBunker_Interface_C::Interface_SetDataFromScan(const TArray<struct FByteArray>& AvailableLocations, const TArray<struct FByteArray>& UnavailableLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_SetDataFromScan");

	Params::Bunker_Interface_C_Interface_SetDataFromScan Parms{};

	Parms.AvailableLocations = std::move(AvailableLocations);
	Parms.UnavailableLocations = std::move(UnavailableLocations);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_SetDrillState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EDrillState                             DrillState                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_SetDrillState(EDrillState DrillState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_SetDrillState");

	Params::Bunker_Interface_C_Interface_SetDrillState Parms{};

	Parms.DrillState = DrillState;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_TeleportPlayer
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AShooterPlayerController*         Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APrimalStructure*                 FromTerminal                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APrimalDinoCharacter*             RidingDino                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    TeleportBoth                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_TeleportPlayer(class AShooterPlayerController* Player, class APrimalStructure* FromTerminal, class APrimalDinoCharacter* RidingDino, bool TeleportBoth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_TeleportPlayer");

	Params::Bunker_Interface_C_Interface_TeleportPlayer Parms{};

	Parms.Player = Player;
	Parms.FromTerminal = FromTerminal;
	Parms.RidingDino = RidingDino;
	Parms.TeleportBoth = TeleportBoth;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_TeleportToLastModule
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class AShooterPlayerController*   Player                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APrimalDinoCharacter*             RidingDino                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_TeleportToLastModule(const class AShooterPlayerController* Player, class APrimalDinoCharacter* RidingDino)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_TeleportToLastModule");

	Params::Bunker_Interface_C_Interface_TeleportToLastModule Parms{};

	Parms.Player = Player;
	Parms.RidingDino = RidingDino;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_TeleportToModule
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Coordinates                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AShooterPlayerController*         Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class APrimalDinoCharacter*             RidingDino                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_TeleportToModule(const struct FVector& Coordinates, class AShooterPlayerController* Player, class APrimalDinoCharacter* RidingDino)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_TeleportToModule");

	Params::Bunker_Interface_C_Interface_TeleportToModule Parms{};

	Parms.Coordinates = std::move(Coordinates);
	Parms.Player = Player;
	Parms.RidingDino = RidingDino;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_ToggleModuleTerminal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AShooterPlayerController*         ForPlayer                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const TArray<uint8>&                    Coordinates                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void IBunker_Interface_C::Interface_ToggleModuleTerminal(class AShooterPlayerController* ForPlayer, const TArray<uint8>& Coordinates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_ToggleModuleTerminal");

	Params::Bunker_Interface_C_Interface_ToggleModuleTerminal Parms{};

	Parms.ForPlayer = ForPlayer;
	Parms.Coordinates = std::move(Coordinates);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function Bunker_Interface.Bunker_Interface_C.Interface_TryRemoveModule
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<uint8>&                    ModuleCoordinates                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AShooterPlayerController*         PC                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void IBunker_Interface_C::Interface_TryRemoveModule(const TArray<uint8>& ModuleCoordinates, class AShooterPlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Bunker_Interface_C", "Interface_TryRemoveModule");

	Params::Bunker_Interface_C_Interface_TryRemoveModule Parms{};

	Parms.ModuleCoordinates = std::move(ModuleCoordinates);
	Parms.PC = PC;

	AsUObject()->ProcessEvent(Func, &Parms);
}

}

