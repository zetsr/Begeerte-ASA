#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: StoredDataPseudoFunctionLibrary

#include "Basic.hpp"

#include "StoredDataPseudoFunctionLibrary_classes.hpp"
#include "StoredDataPseudoFunctionLibrary_parameters.hpp"


namespace SDK
{

// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.AddStoredDataEntry_ViaCopying
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   StoredDataIndex                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Sender_To_Copy_From                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Reciever                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    SkipRoomCheck                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::AddStoredDataEntry_ViaCopying(struct FFunctionParams_NoArrays& Function_Params, int32 StoredDataIndex, class AActor* Sender_To_Copy_From, class FName& Function_Tag, class AActor* Reciever, bool SkipRoomCheck, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "AddStoredDataEntry_ViaCopying");

	Params::StoredDataPseudoFunctionLibrary_C_AddStoredDataEntry_ViaCopying Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.StoredDataIndex = StoredDataIndex;
	Parms.Sender_To_Copy_From = Sender_To_Copy_From;
	Parms.Function_Tag = Function_Tag;
	Parms.Reciever = Reciever;
	Parms.SkipRoomCheck = SkipRoomCheck;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.AttemptTransferDataFromOneTargetToAnotherTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          ActorTransferringFrom                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          ActorToTransferDataTo                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// TArray<int32>&                          StoredDataIndiciesToTransfer                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::AttemptTransferDataFromOneTargetToAnotherTarget(class AActor*& ActorTransferringFrom, class AActor*& ActorToTransferDataTo, TArray<int32>& StoredDataIndiciesToTransfer, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "AttemptTransferDataFromOneTargetToAnotherTarget");

	Params::StoredDataPseudoFunctionLibrary_C_AttemptTransferDataFromOneTargetToAnotherTarget Parms{};

	Parms.ActorTransferringFrom = ActorTransferringFrom;
	Parms.ActorToTransferDataTo = ActorToTransferDataTo;
	Parms.StoredDataIndiciesToTransfer = std::move(StoredDataIndiciesToTransfer);
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	ActorTransferringFrom = Parms.ActorTransferringFrom;
	ActorToTransferDataTo = Parms.ActorToTransferDataTo;
	StoredDataIndiciesToTransfer = std::move(Parms.StoredDataIndiciesToTransfer);
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Can Target Add ANY Stored Data Entry Via Copying
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          ActorTransferringFrom                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          ActorToTransferDataTo                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SkipRoomCheck                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Can_Target_Add_ANY_Stored_Data_Entry_Via_Copying(class AActor*& ActorTransferringFrom, class AActor*& ActorToTransferDataTo, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, bool SkipRoomCheck, class FString* Fail_Reason_String, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Can Target Add ANY Stored Data Entry Via Copying");

	Params::StoredDataPseudoFunctionLibrary_C_Can_Target_Add_ANY_Stored_Data_Entry_Via_Copying Parms{};

	Parms.ActorTransferringFrom = ActorTransferringFrom;
	Parms.ActorToTransferDataTo = ActorToTransferDataTo;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.SkipRoomCheck = SkipRoomCheck;

	UObject::ProcessEvent(Func, &Parms);

	ActorTransferringFrom = Parms.ActorTransferringFrom;
	ActorToTransferDataTo = Parms.ActorToTransferDataTo;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);

	if (success != nullptr)
		*success = Parms.success;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Can Target Add PARTICULAR Stored Data Entry Via Copying
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           SenderTransferringFrom                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           RecieverToTransferDataTo                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SkipRoomCheck                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   can_add                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Can_Target_Add_PARTICULAR_Stored_Data_Entry_Via_Copying(struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class AActor* SenderTransferringFrom, class AActor* RecieverToTransferDataTo, int32 Entry_Index, bool SkipRoomCheck, bool* can_add, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Can Target Add PARTICULAR Stored Data Entry Via Copying");

	Params::StoredDataPseudoFunctionLibrary_C_Can_Target_Add_PARTICULAR_Stored_Data_Entry_Via_Copying Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.SenderTransferringFrom = SenderTransferringFrom;
	Parms.RecieverToTransferDataTo = RecieverToTransferDataTo;
	Parms.Entry_Index = Entry_Index;
	Parms.SkipRoomCheck = SkipRoomCheck;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (can_add != nullptr)
		*can_add = Parms.can_add;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Can Target Remove ANY Stored Data Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          RequestedByActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Can_Target_Remove_ANY_Stored_Data_Entry(struct FFunctionParams_NoArrays& Function_Params, class AActor*& Target, class FName& Function_Tag, class AActor*& RequestedByActor, class FString* Fail_Reason_String, bool* success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Can Target Remove ANY Stored Data Entry");

	Params::StoredDataPseudoFunctionLibrary_C_Can_Target_Remove_ANY_Stored_Data_Entry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Target = Target;
	Parms.Function_Tag = Function_Tag;
	Parms.RequestedByActor = RequestedByActor;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Target = Parms.Target;
	Function_Tag = Parms.Function_Tag;
	RequestedByActor = Parms.RequestedByActor;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);

	if (success != nullptr)
		*success = Parms.success;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Can Target Remove PARTICULAR Stored Data Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*&                          Entry_Owner                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// int32&                                  StoredDataIndexToTransfer                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           RequestedByActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Can_Target_Remove_PARTICULAR_Stored_Data_Entry(struct FFunctionParams_NoArrays& Function_Params, class AActor*& Entry_Owner, int32& StoredDataIndexToTransfer, class FName& Function_Tag, class AActor* RequestedByActor, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Can Target Remove PARTICULAR Stored Data Entry");

	Params::StoredDataPseudoFunctionLibrary_C_Can_Target_Remove_PARTICULAR_Stored_Data_Entry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Entry_Owner = Entry_Owner;
	Parms.StoredDataIndexToTransfer = StoredDataIndexToTransfer;
	Parms.Function_Tag = Function_Tag;
	Parms.RequestedByActor = RequestedByActor;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Entry_Owner = Parms.Entry_Owner;
	StoredDataIndexToTransfer = Parms.StoredDataIndexToTransfer;
	Function_Tag = Parms.Function_Tag;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Can Transfer Data From One Target To Another Target
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorTransferringFrom                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          ActorToTransferDataTo                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// TArray<int32>&                          StoredDataIndiciesToTransfer                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Can_Transfer_Data_From_One_Target_To_Another_Target(class AActor* ActorTransferringFrom, class AActor*& ActorToTransferDataTo, TArray<int32>& StoredDataIndiciesToTransfer, class FName& Function_Tag, struct FFunctionParams_NoArrays& Function_Params, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Can Transfer Data From One Target To Another Target");

	Params::StoredDataPseudoFunctionLibrary_C_Can_Transfer_Data_From_One_Target_To_Another_Target Parms{};

	Parms.ActorTransferringFrom = ActorTransferringFrom;
	Parms.ActorToTransferDataTo = ActorToTransferDataTo;
	Parms.StoredDataIndiciesToTransfer = std::move(StoredDataIndiciesToTransfer);
	Parms.Function_Tag = Function_Tag;
	Parms.Function_Params = std::move(Function_Params);

	UObject::ProcessEvent(Func, &Parms);

	ActorToTransferDataTo = Parms.ActorToTransferDataTo;
	StoredDataIndiciesToTransfer = std::move(Parms.StoredDataIndiciesToTransfer);
	Function_Tag = Parms.Function_Tag;
	Function_Params = std::move(Parms.Function_Params);

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Common Options On Stored Data Entry Button
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Stored_Data_Entry_Owner                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Remote_Actor_To_Transfer_To                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EClientsideEvents_GeneScanner           Event_for_transferring_into_creature                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EClientsideEvents_GeneScanner           Event_for_transferring_from_Creature                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EClientsideEvents_GeneScanner           Event_for_transferring_into_Structure                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EClientsideEvents_GeneScanner           Event_for_transferring_from_Structure                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EClientsideEvents_GeneScanner           Event_For_Destroying                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EClientsideEvents_GeneScanner_VariationsVariant_In_Self                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EClientsideEvents_GeneScanner_VariationsVariant_In_Creature                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EClientsideEvents_GeneScanner_VariationsVariant_In_Structure                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const class FString&                    String_Param_1                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class AActor*                           Actor_To_Call_Event_On                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>*                  Options                                                (Parm, OutParm)
// TArray<bool>*                           Options_enabled                                        (Parm, OutParm)
// class FString*                          local_fail_reason                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Common_Options_On_Stored_Data_Entry_Button(class AActor* Stored_Data_Entry_Owner, class AActor* Remote_Actor_To_Transfer_To, int32 Entry_Index, EClientsideEvents_GeneScanner Event_for_transferring_into_creature, EClientsideEvents_GeneScanner Event_for_transferring_from_Creature, EClientsideEvents_GeneScanner Event_for_transferring_into_Structure, EClientsideEvents_GeneScanner Event_for_transferring_from_Structure, EClientsideEvents_GeneScanner Event_For_Destroying, EClientsideEvents_GeneScanner_Variations Variant_In_Self, EClientsideEvents_GeneScanner_Variations Variant_In_Creature, EClientsideEvents_GeneScanner_Variations Variant_In_Structure, float ID, const class FString& String_Param_1, class AActor* Actor_To_Call_Event_On, TArray<class FString>* Options, TArray<bool>* Options_enabled, class FString* local_fail_reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Common Options On Stored Data Entry Button");

	Params::StoredDataPseudoFunctionLibrary_C_Common_Options_On_Stored_Data_Entry_Button Parms{};

	Parms.Stored_Data_Entry_Owner = Stored_Data_Entry_Owner;
	Parms.Remote_Actor_To_Transfer_To = Remote_Actor_To_Transfer_To;
	Parms.Entry_Index = Entry_Index;
	Parms.Event_for_transferring_into_creature = Event_for_transferring_into_creature;
	Parms.Event_for_transferring_from_Creature = Event_for_transferring_from_Creature;
	Parms.Event_for_transferring_into_Structure = Event_for_transferring_into_Structure;
	Parms.Event_for_transferring_from_Structure = Event_for_transferring_from_Structure;
	Parms.Event_For_Destroying = Event_For_Destroying;
	Parms.Variant_In_Self = Variant_In_Self;
	Parms.Variant_In_Creature = Variant_In_Creature;
	Parms.Variant_In_Structure = Variant_In_Structure;
	Parms.ID = ID;
	Parms.String_Param_1 = std::move(String_Param_1);
	Parms.Actor_To_Call_Event_On = Actor_To_Call_Event_On;

	UObject::ProcessEvent(Func, &Parms);

	if (Options != nullptr)
		*Options = std::move(Parms.Options);

	if (Options_enabled != nullptr)
		*Options_enabled = std::move(Parms.Options_enabled);

	if (local_fail_reason != nullptr)
		*local_fail_reason = std::move(Parms.local_fail_reason);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Does Target Contain PARTICULAR Stored Data Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// int32&                                  StoredDataIndiciesToTransfer                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Does_Target_Contain_PARTICULAR_Stored_Data_Entry(struct FFunctionParams_NoArrays& Function_Params, class AActor*& Target, int32& StoredDataIndiciesToTransfer, class FName& Function_Tag, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Does Target Contain PARTICULAR Stored Data Entry");

	Params::StoredDataPseudoFunctionLibrary_C_Does_Target_Contain_PARTICULAR_Stored_Data_Entry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Target = Target;
	Parms.StoredDataIndiciesToTransfer = StoredDataIndiciesToTransfer;
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Target = Parms.Target;
	StoredDataIndiciesToTransfer = Parms.StoredDataIndiciesToTransfer;
	Function_Tag = Parms.Function_Tag;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Generate Unique ID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 EntryIndex                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Generate_Unique_ID(class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Fail_Reason_String, bool* success, double* EntryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Generate Unique ID");

	Params::StoredDataPseudoFunctionLibrary_C_Generate_Unique_ID Parms{};

	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);

	if (success != nullptr)
		*success = Parms.success;

	if (EntryIndex != nullptr)
		*EntryIndex = Parms.EntryIndex;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Get Available Room For Stored Data
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Available_Room                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Get_Available_Room_For_Stored_Data(class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, int32* Available_Room, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Get Available Room For Stored Data");

	Params::StoredDataPseudoFunctionLibrary_C_Get_Available_Room_For_Stored_Data Parms{};

	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Available_Room != nullptr)
		*Available_Room = Parms.Available_Room;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Get Entry Index From Unique Identifier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  unique_identifier                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  EntryIndex                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Get_Entry_Index_From_Unique_Identifier(double unique_identifier, class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Fail_Reason_String, bool* success, int32* EntryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Get Entry Index From Unique Identifier");

	Params::StoredDataPseudoFunctionLibrary_C_Get_Entry_Index_From_Unique_Identifier Parms{};

	Parms.unique_identifier = unique_identifier;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);

	if (success != nullptr)
		*success = Parms.success;

	if (EntryIndex != nullptr)
		*EntryIndex = Parms.EntryIndex;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Get Unique Identifier For Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 Unique_ID                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Get_Unique_Identifier_For_Entry(int32 Entry_Index, class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Fail_Reason_String, bool* success, double* Unique_ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Get Unique Identifier For Entry");

	Params::StoredDataPseudoFunctionLibrary_C_Get_Unique_Identifier_For_Entry Parms{};

	Parms.Entry_Index = Entry_Index;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);

	if (success != nullptr)
		*success = Parms.success;

	if (Unique_ID != nullptr)
		*Unique_ID = Parms.Unique_ID;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.GetCountOfStoredData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimalItem*                      primal_item_target                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          fail_reason_string_count                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   succeeded_finding_count                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  found_count                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::GetCountOfStoredData(class AActor* Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class UPrimalItem* primal_item_target, class FString* fail_reason_string_count, bool* succeeded_finding_count, int32* found_count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "GetCountOfStoredData");

	Params::StoredDataPseudoFunctionLibrary_C_GetCountOfStoredData Parms{};

	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.primal_item_target = primal_item_target;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (fail_reason_string_count != nullptr)
		*fail_reason_string_count = std::move(Parms.fail_reason_string_count);

	if (succeeded_finding_count != nullptr)
		*succeeded_finding_count = Parms.succeeded_finding_count;

	if (found_count != nullptr)
		*found_count = Parms.found_count;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.GetMaxAllowedStoredDataCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          ForActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String_B                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// int32*                                  max_allowed_count                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   succeeded_getting_max_allowed_count                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::GetMaxAllowedStoredDataCount(class AActor*& ForActor, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Fail_Reason_String_B, int32* max_allowed_count, bool* succeeded_getting_max_allowed_count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "GetMaxAllowedStoredDataCount");

	Params::StoredDataPseudoFunctionLibrary_C_GetMaxAllowedStoredDataCount Parms{};

	Parms.ForActor = ForActor;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	ForActor = Parms.ForActor;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Fail_Reason_String_B != nullptr)
		*Fail_Reason_String_B = std::move(Parms.Fail_Reason_String_B);

	if (max_allowed_count != nullptr)
		*max_allowed_count = Parms.max_allowed_count;

	if (succeeded_getting_max_allowed_count != nullptr)
		*succeeded_getting_max_allowed_count = Parms.succeeded_getting_max_allowed_count;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Is There Room For Transfering Stored Data To Target
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<int32>&                    Transferring_StoredData_Indicies                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*&                          ActorTransferringTo                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool*                                   There_Is_Room                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Is_There_Room_For_Transfering_Stored_Data_To_Target(const TArray<int32>& Transferring_StoredData_Indicies, class AActor*& ActorTransferringTo, class FName& Function_Tag, struct FFunctionParams_NoArrays& Function_Params, bool* There_Is_Room, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Is There Room For Transfering Stored Data To Target");

	Params::StoredDataPseudoFunctionLibrary_C_Is_There_Room_For_Transfering_Stored_Data_To_Target Parms{};

	Parms.Transferring_StoredData_Indicies = std::move(Transferring_StoredData_Indicies);
	Parms.ActorTransferringTo = ActorTransferringTo;
	Parms.Function_Tag = Function_Tag;
	Parms.Function_Params = std::move(Function_Params);

	UObject::ProcessEvent(Func, &Parms);

	ActorTransferringTo = Parms.ActorTransferringTo;
	Function_Tag = Parms.Function_Tag;
	Function_Params = std::move(Parms.Function_Params);

	if (There_Is_Room != nullptr)
		*There_Is_Room = Parms.There_Is_Room;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.IsTargetValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    MustBeCreature                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeOnSameTeam                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeWild                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBePregnantCreature                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustNotBePregnantCreature                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeStructure                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeBabyCreature                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAdultCreature                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeFemale                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeMale                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAlive                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeDead                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             Must_Match_Specific_Class                              (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class AActor*&                          Valid_To_Whom                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             Must_Match_Specific_Dino_Entry_Class                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool*                                   IsValidToBeInteractedWith                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::IsTargetValid(class AActor*& Target, class FName& Function_Tag, struct FFunctionParams_NoArrays& Function_Params, bool MustBeCreature, bool MustBeOnSameTeam, bool MustBeWild, bool MustBePregnantCreature, bool MustNotBePregnantCreature, bool MustBeStructure, bool MustBeBabyCreature, bool MustBeAdultCreature, bool MustBeFemale, bool MustBeMale, bool MustBeAlive, bool MustBeDead, TSoftClassPtr<class UClass> Must_Match_Specific_Class, class AActor*& Valid_To_Whom, TSoftClassPtr<class UClass> Must_Match_Specific_Dino_Entry_Class, bool* IsValidToBeInteractedWith, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "IsTargetValid");

	Params::StoredDataPseudoFunctionLibrary_C_IsTargetValid Parms{};

	Parms.Target = Target;
	Parms.Function_Tag = Function_Tag;
	Parms.Function_Params = std::move(Function_Params);
	Parms.MustBeCreature = MustBeCreature;
	Parms.MustBeOnSameTeam = MustBeOnSameTeam;
	Parms.MustBeWild = MustBeWild;
	Parms.MustBePregnantCreature = MustBePregnantCreature;
	Parms.MustNotBePregnantCreature = MustNotBePregnantCreature;
	Parms.MustBeStructure = MustBeStructure;
	Parms.MustBeBabyCreature = MustBeBabyCreature;
	Parms.MustBeAdultCreature = MustBeAdultCreature;
	Parms.MustBeFemale = MustBeFemale;
	Parms.MustBeMale = MustBeMale;
	Parms.MustBeAlive = MustBeAlive;
	Parms.MustBeDead = MustBeDead;
	Parms.Must_Match_Specific_Class = Must_Match_Specific_Class;
	Parms.Valid_To_Whom = Valid_To_Whom;
	Parms.Must_Match_Specific_Dino_Entry_Class = Must_Match_Specific_Dino_Entry_Class;

	UObject::ProcessEvent(Func, &Parms);

	Target = Parms.Target;
	Function_Tag = Parms.Function_Tag;
	Function_Params = std::move(Parms.Function_Params);
	Valid_To_Whom = Parms.Valid_To_Whom;

	if (IsValidToBeInteractedWith != nullptr)
		*IsValidToBeInteractedWith = Parms.IsValidToBeInteractedWith;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.RemoveStoredDataEntry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   StoredDataIndex                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor_to_Remove_From                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          RequestedByActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::RemoveStoredDataEntry(struct FFunctionParams_NoArrays& Function_Params, int32 StoredDataIndex, class AActor* Actor_to_Remove_From, class FName& Function_Tag, class AActor*& RequestedByActor, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "RemoveStoredDataEntry");

	Params::StoredDataPseudoFunctionLibrary_C_RemoveStoredDataEntry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.StoredDataIndex = StoredDataIndex;
	Parms.Actor_to_Remove_From = Actor_to_Remove_From;
	Parms.Function_Tag = Function_Tag;
	Parms.RequestedByActor = RequestedByActor;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;
	RequestedByActor = Parms.RequestedByActor;

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.Target Is Valid For transfer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          Target_To_Check                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    MustBeCreature                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeOnSameTeam                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeWild                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBePregnantCreature                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustNotBePregnantCreature                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeStructure                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeBabyCreature                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAdultCreature                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeFemale                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeMale                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeAlive                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    MustBeDead                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             Must_Match_Specific_Class                              (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class AActor*&                          Valid_To_Whom                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// TSoftClassPtr<class UClass>             Must_Match_Specific_Dino_Entry_Class                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool*                                   IsValidToBeInteractedWith                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::Target_Is_Valid_For_transfer(class AActor*& Target_To_Check, class FName& Function_Tag, struct FFunctionParams_NoArrays& Function_Params, bool MustBeCreature, bool MustBeOnSameTeam, bool MustBeWild, bool MustBePregnantCreature, bool MustNotBePregnantCreature, bool MustBeStructure, bool MustBeBabyCreature, bool MustBeAdultCreature, bool MustBeFemale, bool MustBeMale, bool MustBeAlive, bool MustBeDead, TSoftClassPtr<class UClass> Must_Match_Specific_Class, class AActor*& Valid_To_Whom, TSoftClassPtr<class UClass> Must_Match_Specific_Dino_Entry_Class, bool* IsValidToBeInteractedWith, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "Target Is Valid For transfer");

	Params::StoredDataPseudoFunctionLibrary_C_Target_Is_Valid_For_transfer Parms{};

	Parms.Target_To_Check = Target_To_Check;
	Parms.Function_Tag = Function_Tag;
	Parms.Function_Params = std::move(Function_Params);
	Parms.MustBeCreature = MustBeCreature;
	Parms.MustBeOnSameTeam = MustBeOnSameTeam;
	Parms.MustBeWild = MustBeWild;
	Parms.MustBePregnantCreature = MustBePregnantCreature;
	Parms.MustNotBePregnantCreature = MustNotBePregnantCreature;
	Parms.MustBeStructure = MustBeStructure;
	Parms.MustBeBabyCreature = MustBeBabyCreature;
	Parms.MustBeAdultCreature = MustBeAdultCreature;
	Parms.MustBeFemale = MustBeFemale;
	Parms.MustBeMale = MustBeMale;
	Parms.MustBeAlive = MustBeAlive;
	Parms.MustBeDead = MustBeDead;
	Parms.Must_Match_Specific_Class = Must_Match_Specific_Class;
	Parms.Valid_To_Whom = Valid_To_Whom;
	Parms.Must_Match_Specific_Dino_Entry_Class = Must_Match_Specific_Dino_Entry_Class;

	UObject::ProcessEvent(Func, &Parms);

	Target_To_Check = Parms.Target_To_Check;
	Function_Tag = Parms.Function_Tag;
	Function_Params = std::move(Parms.Function_Params);
	Valid_To_Whom = Parms.Valid_To_Whom;

	if (IsValidToBeInteractedWith != nullptr)
		*IsValidToBeInteractedWith = Parms.IsValidToBeInteractedWith;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.UI Get Available Options For Interacting WIth An Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   EntryIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Left_Target_Actor                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Right_Target_Actor                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Entry_Is_Held_By_Left_Target_Actor                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>*                  EntryOptions                                           (Parm, OutParm)
// TArray<bool>*                           EntryOptionsEnabled                                    (Parm, OutParm)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::UI_Get_Available_Options_For_Interacting_WIth_An_Entry(struct FFunctionParams_NoArrays& Function_Params, int32 EntryIndex, class FName Function_Tag, class AActor* Left_Target_Actor, class AActor* Right_Target_Actor, bool Entry_Is_Held_By_Left_Target_Actor, TArray<class FString>* EntryOptions, TArray<bool>* EntryOptionsEnabled, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "UI Get Available Options For Interacting WIth An Entry");

	Params::StoredDataPseudoFunctionLibrary_C_UI_Get_Available_Options_For_Interacting_WIth_An_Entry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.EntryIndex = EntryIndex;
	Parms.Function_Tag = Function_Tag;
	Parms.Left_Target_Actor = Left_Target_Actor;
	Parms.Right_Target_Actor = Right_Target_Actor;
	Parms.Entry_Is_Held_By_Left_Target_Actor = Entry_Is_Held_By_Left_Target_Actor;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);

	if (EntryOptions != nullptr)
		*EntryOptions = std::move(Parms.EntryOptions);

	if (EntryOptionsEnabled != nullptr)
		*EntryOptionsEnabled = std::move(Parms.EntryOptionsEnabled);

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.UI Get Display Name For Data Type (PLURAL)
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Name_For_Data_Type                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   Succeded_getting_plural_name                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::UI_Get_Display_Name_For_Data_Type__PLURAL_(struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Name_For_Data_Type, bool* Succeded_getting_plural_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "UI Get Display Name For Data Type (PLURAL)");

	Params::StoredDataPseudoFunctionLibrary_C_UI_Get_Display_Name_For_Data_Type__PLURAL_ Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Name_For_Data_Type != nullptr)
		*Name_For_Data_Type = std::move(Parms.Name_For_Data_Type);

	if (Succeded_getting_plural_name != nullptr)
		*Succeded_getting_plural_name = Parms.Succeded_getting_plural_name;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.UI Get Display Name For Data Type (SINGULAR)
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Ret_Singular_name                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   succeeded_getting_singular_name                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::UI_Get_Display_Name_For_Data_Type__SINGULAR_(struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Ret_Singular_name, bool* succeeded_getting_singular_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "UI Get Display Name For Data Type (SINGULAR)");

	Params::StoredDataPseudoFunctionLibrary_C_UI_Get_Display_Name_For_Data_Type__SINGULAR_ Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Ret_Singular_name != nullptr)
		*Ret_Singular_name = std::move(Parms.Ret_Singular_name);

	if (succeeded_getting_singular_name != nullptr)
		*succeeded_getting_singular_name = Parms.succeeded_getting_singular_name;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.UI Trigger Option for Interacting WIth An Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Entry_Index                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   Option_Chosen                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Entry_Owning_Actor                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Remote_Actor_To_Transfer_To                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          fail_reason_string_for_triggering_entry_action         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   succeeded_triggering_entry_action                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::UI_Trigger_Option_for_Interacting_WIth_An_Entry(struct FFunctionParams_NoArrays& Function_Params, int32 Entry_Index, uint8 Option_Chosen, class FName& Function_Tag, class AActor* Entry_Owning_Actor, class AActor* Remote_Actor_To_Transfer_To, class FString* fail_reason_string_for_triggering_entry_action, bool* succeeded_triggering_entry_action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "UI Trigger Option for Interacting WIth An Entry");

	Params::StoredDataPseudoFunctionLibrary_C_UI_Trigger_Option_for_Interacting_WIth_An_Entry Parms{};

	Parms.Function_Params = std::move(Function_Params);
	Parms.Entry_Index = Entry_Index;
	Parms.Option_Chosen = Option_Chosen;
	Parms.Function_Tag = Function_Tag;
	Parms.Entry_Owning_Actor = Entry_Owning_Actor;
	Parms.Remote_Actor_To_Transfer_To = Remote_Actor_To_Transfer_To;

	UObject::ProcessEvent(Func, &Parms);

	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (fail_reason_string_for_triggering_entry_action != nullptr)
		*fail_reason_string_for_triggering_entry_action = std::move(Parms.fail_reason_string_for_triggering_entry_action);

	if (succeeded_triggering_entry_action != nullptr)
		*succeeded_triggering_entry_action = Parms.succeeded_triggering_entry_action;
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.UI_Get Description For PARTICULAR Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32&                                  StoredData_Index                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Description_For_Entry                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::UI_Get_Description_For_PARTICULAR_Entry(int32& StoredData_Index, class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Description_For_Entry, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "UI_Get Description For PARTICULAR Entry");

	Params::StoredDataPseudoFunctionLibrary_C_UI_Get_Description_For_PARTICULAR_Entry Parms{};

	Parms.StoredData_Index = StoredData_Index;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	StoredData_Index = Parms.StoredData_Index;
	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Description_For_Entry != nullptr)
		*Description_For_Entry = std::move(Parms.Description_For_Entry);

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.UI_Get Detailed Description For PARTICULAR Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32&                                  StoredData_Index                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Description_For_Entry                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Fail_Reason_String                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::UI_Get_Detailed_Description_For_PARTICULAR_Entry(int32& StoredData_Index, class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* Description_For_Entry, bool* success, class FString* Fail_Reason_String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "UI_Get Detailed Description For PARTICULAR Entry");

	Params::StoredDataPseudoFunctionLibrary_C_UI_Get_Detailed_Description_For_PARTICULAR_Entry Parms{};

	Parms.StoredData_Index = StoredData_Index;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	StoredData_Index = Parms.StoredData_Index;
	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (Description_For_Entry != nullptr)
		*Description_For_Entry = std::move(Parms.Description_For_Entry);

	if (success != nullptr)
		*success = Parms.success;

	if (Fail_Reason_String != nullptr)
		*Fail_Reason_String = std::move(Parms.Fail_Reason_String);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.UI_Get Display Name For PARTICULAR Entry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32&                                  StoredData_Index                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimalItem*                      primal_item_target                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString*                          ret_name_for_particular_entry                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   succeeded_getting_name_for_particular_entry            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          ret_fail_reason_string_for_getting_name_of_particular_entry(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::UI_Get_Display_Name_For_PARTICULAR_Entry(int32& StoredData_Index, class AActor* Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class UPrimalItem* primal_item_target, class FString* ret_name_for_particular_entry, bool* succeeded_getting_name_for_particular_entry, class FString* ret_fail_reason_string_for_getting_name_of_particular_entry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "UI_Get Display Name For PARTICULAR Entry");

	Params::StoredDataPseudoFunctionLibrary_C_UI_Get_Display_Name_For_PARTICULAR_Entry Parms{};

	Parms.StoredData_Index = StoredData_Index;
	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;
	Parms.primal_item_target = primal_item_target;

	UObject::ProcessEvent(Func, &Parms);

	StoredData_Index = Parms.StoredData_Index;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (ret_name_for_particular_entry != nullptr)
		*ret_name_for_particular_entry = std::move(Parms.ret_name_for_particular_entry);

	if (succeeded_getting_name_for_particular_entry != nullptr)
		*succeeded_getting_name_for_particular_entry = Parms.succeeded_getting_name_for_particular_entry;

	if (ret_fail_reason_string_for_getting_name_of_particular_entry != nullptr)
		*ret_fail_reason_string_for_getting_name_of_particular_entry = std::move(Parms.ret_fail_reason_string_for_getting_name_of_particular_entry);
}


// Function StoredDataPseudoFunctionLibrary.StoredDataPseudoFunctionLibrary_C.UI_GetDisplayNameForTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*&                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// struct FFunctionParams_NoArrays&        Function_Params                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FName&                            Function_Tag                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          ret_name                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   succeeded_getting_displawy_name_for_target             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          Ret_Fail_Rason                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UStoredDataPseudoFunctionLibrary_C::UI_GetDisplayNameForTarget(class AActor*& Target, struct FFunctionParams_NoArrays& Function_Params, class FName& Function_Tag, class FString* ret_name, bool* succeeded_getting_displawy_name_for_target, class FString* Ret_Fail_Rason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoredDataPseudoFunctionLibrary_C", "UI_GetDisplayNameForTarget");

	Params::StoredDataPseudoFunctionLibrary_C_UI_GetDisplayNameForTarget Parms{};

	Parms.Target = Target;
	Parms.Function_Params = std::move(Function_Params);
	Parms.Function_Tag = Function_Tag;

	UObject::ProcessEvent(Func, &Parms);

	Target = Parms.Target;
	Function_Params = std::move(Parms.Function_Params);
	Function_Tag = Parms.Function_Tag;

	if (ret_name != nullptr)
		*ret_name = std::move(Parms.ret_name);

	if (succeeded_getting_displawy_name_for_target != nullptr)
		*succeeded_getting_displawy_name_for_target = Parms.succeeded_getting_displawy_name_for_target;

	if (Ret_Fail_Rason != nullptr)
		*Ret_Fail_Rason = std::move(Parms.Ret_Fail_Rason);
}

}

