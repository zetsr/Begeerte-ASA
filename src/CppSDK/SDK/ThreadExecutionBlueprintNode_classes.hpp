#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ThreadExecutionBlueprintNode

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "ThreadExecutionBlueprintNode_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class ThreadExecutionBlueprintNode.AsyncExecutionBlueprintTypes
// 0x0000 (0x0028 - 0x0028)
class UAsyncExecutionBlueprintTypes final : public UBlueprintFunctionLibrary
{
public:
	static ETickingGroup Conv_ThreadTickTimingToTickingGroup(const EThreadTickTiming& ThreadTickTiming);
	static EThreadTickTiming Conv_TickingGroupToThreadTickTiming(const ETickingGroup& TickGroup);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("AsyncExecutionBlueprintTypes")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"AsyncExecutionBlueprintTypes")
	}
	static class UAsyncExecutionBlueprintTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncExecutionBlueprintTypes>();
	}
};
DUMPER7_ASSERTS_UAsyncExecutionBlueprintTypes;

// Class ThreadExecutionBlueprintNode.Mutex
// 0x0028 (0x0050 - 0x0028)
class UMutex final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Lock();
	bool TryLock();
	void UnLock();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("Mutex")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"Mutex")
	}
	static class UMutex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMutex>();
	}
};
DUMPER7_ASSERTS_UMutex;

// Class ThreadExecutionBlueprintNode.SyncExecOnce
// 0x0010 (0x0040 - 0x0030)
class USyncExecOnce final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnExecution;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USyncExecOnce* CreateSyncExecOnce();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("SyncExecOnce")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"SyncExecOnce")
	}
	static class USyncExecOnce* GetDefaultObj()
	{
		return GetDefaultObjImpl<USyncExecOnce>();
	}
};
DUMPER7_ASSERTS_USyncExecOnce;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecBase
// 0x0028 (0x0058 - 0x0030)
class UThreadAsyncExecBase : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecBase")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecBase")
	}
	static class UThreadAsyncExecBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecBase>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecBase;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecLibrary
// 0x0000 (0x0028 - 0x0028)
class UThreadAsyncExecLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ExecIsGameThread(bool* bIsInGameThread);
	static void GameThreadExecOnce(const TDelegate<void()>& GameThreadExec);
	static int32 GetCurrentThreadID();
	static class FName GetThreadName();
	static bool IsGameThread();
	static bool SetThreadName(class FName ThreadName);
	static void ThreadWait(float Seconds);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecLibrary")
	}
	static class UThreadAsyncExecLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecLibrary>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecLibrary;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecLoopUnsafely
// 0x0030 (0x0088 - 0x0058)
class UThreadAsyncExecLoopUnsafely final : public UThreadAsyncExecBase
{
public:
	TMulticastInlineDelegate<void(class UThreadAsyncExecLoopUnsafely* LoopHandle)> OnLoopBody;       // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UThreadAsyncExecLoopUnsafely* CreateThreadExecLoopUnsafely(float Interval, bool bLongTask, class FName ThreadName, bool bBlockGC);

	void BreakNextLoop();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecLoopUnsafely")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecLoopUnsafely")
	}
	static class UThreadAsyncExecLoopUnsafely* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecLoopUnsafely>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecLoopUnsafely;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecOnce
// 0x0040 (0x0098 - 0x0058)
class UThreadAsyncExecOnce final : public UThreadAsyncExecBase
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnExecution;                                       // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UThreadAsyncExecOnce* CreateThreadExecOnce(bool bExecuteWhenPaused, bool bLongTask, class FName ThreadName, const struct FThreadExecTimingPair& TimingPair);

	bool IsExecuteWhenPaused() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecOnce")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecOnce")
	}
	static class UThreadAsyncExecOnce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecOnce>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecOnce;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecOnceUnsafely
// 0x0028 (0x0080 - 0x0058)
class UThreadAsyncExecOnceUnsafely final : public UThreadAsyncExecBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnExecution;                                       // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UThreadAsyncExecOnceUnsafely* CreateThreadExecOnceUnsafely(bool bLongTask, class FName ThreadName, bool bBlockGC);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecOnceUnsafely")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecOnceUnsafely")
	}
	static class UThreadAsyncExecOnceUnsafely* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecOnceUnsafely>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecOnceUnsafely;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecTickBase
// 0x0030 (0x0088 - 0x0058)
class UThreadAsyncExecTickBase : public UThreadAsyncExecBase
{
public:
	uint8                                         Pad_58[0x30];                                      // 0x0058(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BreakNextTick();
	void SetTickableWhenPaused(bool NewValue);
	void SetTickEnabled(bool NewValue);

	struct FThreadTickExecBehavior GetBehavior() const;
	struct FThreadExecTimingPair GetTimingPair() const;
	bool IsTickableWhenPaused() const;
	bool IsTickEnabled() const;
	bool IsTicking() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecTickBase")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecTickBase")
	}
	static class UThreadAsyncExecTickBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecTickBase>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecTickBase;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecTick
// 0x0030 (0x00B8 - 0x0088)
class UThreadAsyncExecTick final : public UThreadAsyncExecTickBase
{
public:
	TMulticastInlineDelegate<void(float DeltaSeconds, class UThreadAsyncExecTick* TickHandle)> OnExecution; // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTickEnd;                                         // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UThreadAsyncExecTick* CreateThreadExecTick(bool bTickEnabled, bool bTickWhenPaused, bool bLongTask, class FName ThreadName, const struct FThreadExecTimingPair& TimingPair, const struct FThreadTickExecBehavior& Behavior);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecTick")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecTick")
	}
	static class UThreadAsyncExecTick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecTick>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecTick;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecTickForLoop
// 0x0040 (0x00C8 - 0x0088)
class UThreadAsyncExecTickForLoop final : public UThreadAsyncExecTickBase
{
public:
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 Index, float DeltaSeconds, class UThreadAsyncExecTickForLoop* TickHandle)> OnExecution; // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTickEnd;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UThreadAsyncExecTickForLoop* CreateThreadExecTickForLoop(int32 FirstIndex, int32 LastIndex, bool bTickEnabled, bool bTickWhenPaused, bool bLongTask, class FName ThreadName, const struct FThreadExecTimingPair& TimingPair, const struct FThreadTickExecBehavior& Behavior);

	int32 GetCurrentIndex() const;
	int32 GetFirstIndex() const;
	int32 GetLastIndex() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecTickForLoop")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecTickForLoop")
	}
	static class UThreadAsyncExecTickForLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecTickForLoop>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecTickForLoop;

// Class ThreadExecutionBlueprintNode.ThreadAsyncExecTickUnsafely
// 0x0040 (0x0098 - 0x0058)
class UThreadAsyncExecTickUnsafely final : public UThreadAsyncExecBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float DeltaSeconds, class UThreadAsyncExecTickUnsafely* TickHandle)> OnTick; // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UThreadAsyncExecTickUnsafely* CreateThreadExecTickUnsafely(bool TickEnabled, bool TickWhenPaused, bool bLongTask, class FName ThreadName, bool bBlockGC);

	void BreakNextTick();
	void SetTickable(bool NewValue);
	void SetTickableWhenPaused(bool NewValue);

	bool IsTickable() const;
	bool IsTickableWhenPaused() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadAsyncExecTickUnsafely")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadAsyncExecTickUnsafely")
	}
	static class UThreadAsyncExecTickUnsafely* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadAsyncExecTickUnsafely>();
	}
};
DUMPER7_ASSERTS_UThreadAsyncExecTickUnsafely;

// Class ThreadExecutionBlueprintNode.ThreadExecDeveloperSettings
// 0x0000 (0x0038 - 0x0038)
class UThreadExecDeveloperSettings final : public UDeveloperSettings
{
public:
	static class UThreadExecDeveloperSettings* Get();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadExecDeveloperSettings")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadExecDeveloperSettings")
	}
	static class UThreadExecDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadExecDeveloperSettings>();
	}
};
DUMPER7_ASSERTS_UThreadExecDeveloperSettings;

// Class ThreadExecutionBlueprintNode.ThreadNodeSubsystem
// 0x0078 (0x00A8 - 0x0030)
class UThreadNodeSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x78];                                      // 0x0030(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMutex* CreateNewMutex();
	void DestoryMutex(class UMutex* Mutex);
	TSet<class UMutex*> GetAllMutexes();
	TSet<class UThreadAsyncExecLoopUnsafely*> GetAllThreadExecLoops();
	TSet<class UThreadAsyncExecBase*> GetAllThreadExecNodes();
	TSet<class UThreadAsyncExecOnce*> GetAllThreadExecOnces();
	TSet<class UThreadAsyncExecTickBase*> GetAllThreadExecTicks();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ThreadNodeSubsystem")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ThreadNodeSubsystem")
	}
	static class UThreadNodeSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreadNodeSubsystem>();
	}
};
DUMPER7_ASSERTS_UThreadNodeSubsystem;

// Class ThreadExecutionBlueprintNode.TickListenerSubsystem
// 0x0028 (0x0058 - 0x0030)
class UTickListenerSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UThreadNodeSubsystem*                   ThreadNodeSubsystem;                               // 0x0050(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected, ExperimentalNeverOverriden)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("TickListenerSubsystem")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"TickListenerSubsystem")
	}
	static class UTickListenerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickListenerSubsystem>();
	}
};
DUMPER7_ASSERTS_UTickListenerSubsystem;

}

